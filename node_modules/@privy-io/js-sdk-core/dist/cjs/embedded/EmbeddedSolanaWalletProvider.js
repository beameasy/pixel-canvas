"use strict";var e=require("../Error.js"),r=require("../solana/getWalletPublicKeyFromTransaction.js"),t=require("../solana/isVersionedTransaction.js");exports.EmbeddedSolanaWalletProvider=class{async request(r){if(!await this._privyInternal.getAccessToken())throw new e.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});switch(r.method){case"signAndSendTransaction":return await this.handleSignAndSendTransaction(r);case"signTransaction":return await this.handleSignTransaction(r);default:return await this.handleIFrameRpc(r)}}async handleIFrameRpc(r){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:r.method,address:this._publicKey}),(await this._proxy.rpcWallet({accessToken:e,request:r,chainType:"solana",hdWalletIndex:this._hdWalletIndex,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data}catch(t){console.error(t);let a=t instanceof Error?t.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:r.method,address:this._publicKey,error:a}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:a})}}async handleSignAndSendTransaction(a){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._publicKey});let{transaction:s,connection:i,options:n}=a.params,o=r.getWalletPublicKeyFromTransaction(s,this._publicKey),d=t.isVersionedTransaction(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),l=(await this._proxy.rpcWallet({accessToken:e,chainType:"solana",hdWalletIndex:this._hdWalletIndex,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,request:{method:"signMessage",params:{message:d.toString("base64")}}})).response.data.signature;return s.addSignature(o,Buffer.from(l,"base64")),{signature:await i.sendRawTransaction(s.serialize(),n)}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._publicKey,error:t}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}async handleSignTransaction(a){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._publicKey});let{transaction:s}=a.params,i=r.getWalletPublicKeyFromTransaction(s,this._publicKey),n=t.isVersionedTransaction(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),o=(await this._proxy.rpcWallet({accessToken:e,chainType:"solana",hdWalletIndex:this._hdWalletIndex,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,request:{method:"signMessage",params:{message:n.toString("base64")}}})).response.data.signature;return s.addSignature(i,Buffer.from(o,"base64")),{signedTransaction:s}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._publicKey,error:t}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._publicKey}', request: [Function] }`}constructor({proxy:e,privyInternal:r,publicKey:t,hdWalletIndex:a,entropyId:s,entropyIdVerifier:i}){this._proxy=e,this._privyInternal=r,this._publicKey=t,this._hdWalletIndex=a,this._entropyId=s,this._entropyIdVerifier=i}};

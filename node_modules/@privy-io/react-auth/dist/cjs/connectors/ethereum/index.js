"use strict";var e=require("viem/utils"),t=require("../../constants.js"),r=require("../../errors.js"),i=require("../../storage.js"),n=require("../../utils/index.js"),s=require("../areWalletArraysEqual.js"),a=require("../base.js"),o=require("../getRpcTimeout.js");require("ofetch"),require("../get-legacy-injected-providers.js"),require("../is-wallet-installed.js"),require("../../utils/eth/getPublicClient.js"),require("viem"),require("../isBaseConnectedEthereumWallet.js"),require("eventemitter3");class l extends a.WalletConnector{buildConnectedWallet(t,i,s,a){let o=async()=>!!this.wallets.find((r=>e.getAddress(r.address)===e.getAddress(t)));return{type:"ethereum",address:e.getAddress(t),chainId:i,meta:s,imported:a,switchChain:async s=>{let a,l;if(!o)throw new r.PrivyConnectorError("Wallet is not currently connected.");let c=this.wallets.find((r=>e.getAddress(r.address)===e.getAddress(t)))?.chainId;if(!c)throw new r.PrivyConnectorError("Unable to determine current chainId.");if("number"==typeof s?(a=`0x${s.toString(16)}`,l=s):(a=s,l=Number(s)),c===n.formatChainIdToCAIP2(a))return;let d=this.chains.find((e=>e.id===l));if(!d)throw new r.PrivyConnectorError(`Unsupported chainId: ${s}`);let h=async()=>{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:a}]})};try{return await h()}catch(e){if(((e,t)=>{switch(t){case"coinbase_wallet":return e.message.includes("addEthereumChain");case"rabby_wallet":return e.message.includes("Unrecognized chain ID");default:return 4902===e.code||e.message?.includes("4902")}})(e,this.walletClientType))return"rabby_wallet"===this.walletClientType&&await n.sleep(300),await this.proxyProvider.request({method:"wallet_addEthereumChain",params:[{chainId:a,chainName:d.name,nativeCurrency:d.nativeCurrency,rpcUrls:[d.rpcUrls.default?.http[0]??""],blockExplorerUrls:[d.blockExplorers?.default.url??""]}]}),h();if("rainbow"===this.walletClientType&&e.message?.includes("wallet_switchEthereumChain"))throw new r.PrivyConnectorError(`Rainbow does not support the chainId ${i}`);throw e}},connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:o,getEthereumProvider:async()=>{if(!await o())throw new r.PrivyConnectorError("Wallet is not currently connected.");return this.proxyProvider},sign:async e=>{if(!await o())throw new r.PrivyConnectorError("Wallet is not currently connected.");return await this.sign(e)},disconnect:()=>{this.disconnect()}}}async syncAccounts(r){let a,o=r;try{if(void 0===o){let e=await n.invokeUntilSettled((()=>this.proxyProvider.request({method:"eth_accounts"})),{maxAttempts:10,delayMs:500});console.debug(`eth_accounts for ${this.walletClientType}:`,e),Array.isArray(e)&&(o=e)}}catch(e){console.debug("Wallet did not respond to eth_accounts. Defaulting to prefetched accounts.",e)}if(!o||!Array.isArray(o)||o.length<=0||!o[0])return;let l=o[0],c=e.getAddress(l),d=[];if("privy"===this.walletClientType){let e=i.default.get(t.getPrivyWalletKey(c));this.chains.find((t=>t.id===Number(e)))||(i.default.del(t.getPrivyWalletKey(c)),e=null),a=e||`0x${this.defaultChain.id.toString(16)}`;try{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:a}]})}catch(e){console.warn(`Unable to switch embedded wallet to chain ID ${a} on initialization`)}}else try{let e=await n.invokeUntilSettled((()=>this.proxyProvider.request({method:"eth_chainId"})),{maxAttempts:10,delayMs:500});if(console.debug(`eth_chainId for ${this.walletClientType}:`,e),"string"==typeof e)a=e;else{if("number"!=typeof e)throw Error("Invalid chainId returned from provider");a=`0x${e.toString(16)}`}}catch(e){console.warn(`Failed to get chainId from provider, defaulting to ${t.DEFAULT_NETWORK}`,e),a=t.DEFAULT_NETWORK}let h=n.formatChainIdToCAIP2(a);if(!d.find((t=>e.getAddress(t.address)===c))){let t={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};d.push(this.buildConnectedWallet(e.getAddress(l),h,t,"embedded_imported"===this.connectorType))}s.areWalletArraysEqual(d,this.wallets)||(this.wallets=d,this.emit("walletsUpdated"))}async getConnectedWallet(){let t=await this.proxyProvider.request({method:"eth_accounts"});return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt)).find((r=>t.find((t=>e.getAddress(t)===e.getAddress(r.address)))))||null}async isConnected(){let e=await this.proxyProvider.request({method:"eth_accounts"});return Array.isArray(e)&&e.length>0}async sign(t){return await this.connect({showPrompt:!1}),this.proxyProvider.request({method:"personal_sign",params:[e.toHex(t),this.wallets[0]?.address]})}subscribeListeners(){this.proxyProvider.on("accountsChanged",this.onAccountsChanged),this.proxyProvider.on("chainChanged",this.onChainChanged),this.proxyProvider.on("disconnect",this.onDisconnect),this.proxyProvider.on("connect",this.onConnect)}unsubscribeListeners(){this.proxyProvider.removeListener("accountsChanged",this.onAccountsChanged),this.proxyProvider.removeListener("chainChanged",this.onChainChanged),this.proxyProvider.removeListener("disconnect",this.onDisconnect),this.proxyProvider.removeListener("connect",this.onConnect)}constructor(e,r,s,a){super(e),this.chainType="ethereum",this.onAccountsChanged=e=>{0===e.length?this.onDisconnect():this.syncAccounts(e)},this.onChainChanged=e=>{this.wallets.forEach((r=>{r.chainId=n.formatChainIdToCAIP2(e),"privy"===this.walletClientType&&i.default.put(t.getPrivyWalletKey(r.address),e)})),this.emit("walletsUpdated")},this.onDisconnect=()=>{this.connected=!1,this.wallets=[],this.emit("walletsUpdated")},this.onConnect=()=>{this.connected=!0,this.syncAccounts()},this.wallets=[],this.walletClientType=e,this.chains=r,this.defaultChain=s,this.rpcConfig=a,this.rpcTimeoutDuration=o.getRpcTimeout(a,e),this.connected=!1,this.initialized=!1}}exports.EthereumWalletConnector=l,exports.isEthereumWalletConnector=function(e){return"ethereum"===e.chainType};

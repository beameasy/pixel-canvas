import{jsxs as e,Fragment as o,jsx as t}from"react/jsx-runtime";import n from"@heroicons/react/24/outline/CheckCircleIcon";import{useState as i,useEffect as r}from"react";import{parseEther as s,createWalletClient as a,custom as c,publicActions as m,createPublicClient as l,http as d,encodeFunctionData as p,formatUnits as u}from"viem";import{RefactorSpacerTop as h,CenteredItemWithGap as g,RefactorSpacerBottom as j}from"../../components/Layouts.mjs";import{BlobbyFooter as f}from"../../components/ModalFooter.mjs";import{CenteredScreenHeader as v}from"../../components/ScreenHeader.mjs";import y from"../../components/embedded-wallets/FundWalletMethodHeader.mjs";import{NeutralSpinner as b}from"../../components/primitives/NeutralSpinner/index.mjs";import{addToDefaultChains as w}from"../../connectors/chains/utils.mjs";import{DEFAULT_SUCCESS_SCREEN_EXTRA_LONG_DURATION_MS as I}from"../../constants.mjs";import{PrivyClientError as C,PrivyErrorCode as T}from"../../errors.mjs";import{usePrivyInternal as S}from"../../hooks/internal-context.mjs";import{usePrivyModal as k}from"../../hooks/modal-context.mjs";import{useGetTokenPrice as N}from"../../hooks/useGetTokenPrice.mjs";import{useWallets as A}from"../../hooks/useWallets.mjs";import{ERC20_TRANSFER_ABI_STUB as E}from"../../lib/erc20/actions/abis/transfer.mjs";import{formatErc20TokenAmount as x}from"../../lib/erc20/formatErc20TokenAmount.mjs";import{getDollarsFromStringFloat as F,sumWeiQuantities as B,getDollarsFromWei as L,getNativeCurrencyFromWei as M}from"../../lib/ethers.mjs";import{toDisplayName as P}from"../../lib/external-wallets/displayHelpers.mjs";import{ON_RAMP_COMPLETE_ANALYTICS_EVENT as R}from"../../lib/funding/analytics.mjs";import{getQuote as H,toGetQuoteInput as U,toEvmTransactionRequestInfoFromQuote as W,useBridgingStatusPolling as _}from"../../lib/funding/reservoir.mjs";import{getBalanceForChains as q}from"../../lib/wallets/actions/getBalanceForChains.mjs";import{getErc20Balance as $}from"../../lib/wallets/actions/getErc20Balance.mjs";import{formatWalletAddress as O}from"../../utils/index.mjs";import{getJsonRpcEndpointFromChain as z}from"../../utils/eth/getPublicClient.mjs";import{ModalScreen as D}from"../index.mjs";import{BridgeNetworkSelectionView as G}from"./BridgeNetworkSelectionView.mjs";import{TransferOrBridgeLoadingScreen as V}from"./TransferOrBridgeLoadingScreen.mjs";import"styled-components";import"../../configuration/context.mjs";import"../../config.mjs";import"../../configuration/defaultClientConfig.mjs";import"../../configuration/login-methods.mjs";import"../../configuration/wallets.mjs";import"../../connectors/chains/index.mjs";import"../../connectors/chains/arbitrum.mjs";import"../../connectors/chains/arbitrumSepolia.mjs";import"../../connectors/chains/avalanche.mjs";import"../../connectors/chains/avalancheFuji.mjs";import"../../connectors/chains/base.mjs";import"../../connectors/chains/baseSepolia.mjs";import"../../connectors/chains/berachainArtio.mjs";import"../../connectors/chains/celo.mjs";import"../../connectors/chains/celoAlfajores.mjs";import"../../connectors/chains/filecoin.mjs";import"../../connectors/chains/filecoinCalibration.mjs";import"../../connectors/chains/garnetHolesky.mjs";import"../../connectors/chains/holesky.mjs";import"../../connectors/chains/linea.mjs";import"../../connectors/chains/lineaTestnet.mjs";import"../../connectors/chains/lukso.mjs";import"../../connectors/chains/mainnet.mjs";import"../../connectors/chains/optimism.mjs";import"../../connectors/chains/optimismSepolia.mjs";import"../../connectors/chains/polygon.mjs";import"../../connectors/chains/polygonAmoy.mjs";import"../../connectors/chains/redstone.mjs";import"../../connectors/chains/sepolia.mjs";import"../../connectors/chains/zora.mjs";import"../../connectors/chains/zoraSepolia.mjs";import"../../connectors/chains/zoraTestnet.mjs";import"../../lib/solana/index.mjs";import"../../theme.mjs";import"tinycolor2";import"../../lib/cybr53.mjs";import"../../svg/protected-by-privy.mjs";import"../../components/ModalHeader.mjs";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"../../hooks/index.mjs";import"ofetch";import"../../components/PrefetchedImage.mjs";import"../../hooks/useGetSolPrice.mjs";import"../../connectors/get-legacy-injected-providers.mjs";import"../../connectors/is-wallet-installed.mjs";import"../../svg/backpack.mjs";import"../../svg/brave-browser-icon.mjs";import"../../svg/bybit.mjs";import"../../svg/coinbase-wallet.mjs";import"../../svg/cryptocom.mjs";import"../../svg/metamask.mjs";import"../../svg/okx-wallet.mjs";import"../../svg/phantom.mjs";import"../../svg/rabby.mjs";import"../../svg/rainbow.mjs";import"../../svg/safe.mjs";import"../../svg/solflare.mjs";import"../../svg/uniswap.mjs";import"../../svg/universal-profile.mjs";import"../../svg/wallet-connect.mjs";import"../../svg/zerion.mjs";import"@privy-io/js-sdk-core";import"../../components/Button.mjs";import"../../components/Loader.mjs";import"../../components/ui/layout/Row.mjs";import"../../components/ui/typography/ErrorMessage.mjs";import"../../components/ui/typography/LabelSm.mjs";import"../../components/ui/typography/Subtitle.mjs";import"../../components/ui/typography/Title.mjs";import"../../components/ui/wallet/NetworkBalanceCard.mjs";import"@heroicons/react/24/outline/WalletIcon";import"../../components/ui/chips/Chip.mjs";import"../../components/ui/animation/LoadingSkeleton.mjs";import"../../components/ui/typography/Value.mjs";import"../../components/ui/wallet/NetworkIcon.mjs";import"@heroicons/react/24/outline/GlobeAltIcon";import"../../components/ui/icons/Arbitum.mjs";import"../../components/ui/icons/Avalanche.mjs";import"../../components/ui/icons/Base.mjs";import"../../components/ui/icons/Celo.mjs";import"../../components/ui/icons/Linea.mjs";import"../../components/ui/icons/Mainnnet.mjs";import"../../components/ui/icons/Optimism.mjs";import"../../components/ui/icons/Polygon.mjs";import"../../components/ui/icons/Solana.mjs";import"../../components/ui/icons/Zora.mjs";import"../../components/ui/wallet/shared.mjs";import"../../components/ui/wallet/NetworkSelectorPanel.mjs";import"@headlessui/react";import"@heroicons/react/24/outline/ChevronDownIcon";import"./styles.mjs";import"../LinkPasskeyScreen.mjs";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"../../hooks/privy-context.mjs";import"../../svg/face-id.mjs";import"../../svg/fingerprint.mjs";import"../MfaScreens/StyledComponents.mjs";import"../../components/external-wallets/InjectedWalletIcon.mjs";import"../../components/ui/wallet/Address.mjs";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";const Q=()=>{let{rpcConfig:Q,appId:X,closePrivyModal:Y,createAnalyticsEvent:Z}=S(),{navigate:J,setModalData:K,app:ee,data:oe}=k(),{wallets:te}=A(),[ne,ie]=i(!1),[re,se]=i(0n),[ae,ce]=i(!1),[me,le]=i(null),[de,pe]=i(null),[ue,he]=i([]),[ge,je]=i(0),[fe,ve]=i(!1),[ye,be]=i(!1),[we,Ie]=i(!1),[Ce,Te]=i(!1),[Se,ke]=i(),[Ne,Ae]=i();if(!oe?.funding||"ethereum"!==oe.funding.chainType)throw Error("Invalid funding data");let{erc20ContractInfo:Ee,chain:xe,connectedWalletAddress:Fe}=oe.funding,Be=oe.funding.address,Le=oe.funding.erc20Address,[Me,Pe]=i(oe.funding.amount);r((()=>{Le&&!Ee&&le(Error("Unable to fetch token details"))}),[]);let Re=!!Le&&!!Ee,He=Re?BigInt(parseFloat(Me)*10**Ee.decimals):s(Me),Ue=Fe?te.find((({address:e})=>e===Fe)):te[0],[We,_e]=i(null);r((()=>{(async()=>{if(!Ue)return;let e=await Ue.getEthereumProvider();_e(a({account:Ue.address,transport:c(e)}).extend(m))})().catch(console.error)}),[Ue]);let[qe,$e]=i(0n);r((()=>{l({chain:xe,transport:d(z(xe,Q,X))}).getBalance({address:Be}).then($e).catch(console.error)}),[]);let[Oe,ze]=i(0n);r((()=>{Re&&$({chain:xe,address:Be,appId:X,rpcConfig:Q,erc20Address:Le}).then((e=>ze(e.balance))).catch(console.error)}),[]);let{tokenPrice:De}=N(xe.id),[Ge,Ve]=i({to:Be,chain:xe,value:He,data:void 0});r((()=>{(async()=>{let e,o;if(!We||!Ue||fe||we)return;ve(!0);let t=l({chain:Ge.chain,transport:d(z(Ge.chain,Q,X))});if(Re&&!Ge.data)return await t.simulateContract({address:Le,chain:Ge.chain,abi:E,functionName:"transfer",args:[Be,He],account:Ue.address}).catch((e=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",e)}))?(ve(!1),void Ve({to:Le,chain:Ge.chain,data:p({abi:E,functionName:"transfer",args:[Be,He]}),value:"0x0"})):(ve(!1),void ce(!0));try{e=await t.prepareTransactionRequest({account:Ue.address,to:Ge.to,chain:Ge.chain,data:Ge.data,value:BigInt(Ge.value??0)})}catch(e){if(console.error(e),ue.length>1)pe(e.shortMessage??"Something went wrong");else if(ye&&0===ue.length)return void le(new C(`Wallet ${O(Ue.address)} does not have enough funds.`,void 0,T.INSUFFICIENT_BALANCE))}if(!e)return ve(!1),void ce(!0);ve(!1),Ie(!0),ie(!0),se(e.gas);try{await We.switchChain({id:Ge.chain.id})}catch(e){await We.addChain({chain:Ge.chain}),await We.switchChain({id:Ge.chain.id})}try{o=await We.sendTransaction(e)}catch(e){if(console.error(e),"TransactionExecutionError"===e.name)if(ue.length<1){let o=e.shortMessage;(e.shortMessage.includes("rejected the request")||e.details.includes("rejected the request"))&&(o="User rejected the request."),le(new C(o,void 0,T.TRANSACTION_FAILURE))}else pe(e.shortMessage??"Something went wrong")}if(o)return await We.waitForTransactionReceipt({hash:o}),Ie(!1),ye?(ke(o),void Ae("pending")):(Te(!0),void Z({eventName:R,payload:{provider:"external",status:"success",txHash:o,address:Ue.address,chainId:Ge.chain.id,chainType:"ethereum",value:Ge.value?u(BigInt(Ge.value),Ee?.decimals??18):void 0,token:Ee?.symbol??Le??"ETH",destinationAddress:Be,destinationChainId:xe.id,destinationChainType:"ethereum",destinationValue:He?u(He,Ee?.decimals??18):void 0,destinationToken:Ee?.symbol??Le??xe.nativeCurrency.name}}));Ie(!1)})().catch(console.error)}),[We,Ge]),r((()=>{(async()=>{if(!ae||!We||!Ue)return;let e=w(ee.chains).filter((e=>e.id!==xe.id&&!!e.testnet==!!xe.testnet));Re&&e.unshift(xe);let o=await q({chains:e,address:Ue.address,appId:X,rpcConfig:Q}),t=Re?o.filter((e=>e.balance>0n)):o.filter((e=>e.balance>He));if(t.length<1)return void le(new C(`Wallet ${O(Ue.address)} does not have enough funds.`,void 0,T.INSUFFICIENT_BALANCE));t.sort(((e,o)=>Number(o.balance-e.balance)));let n=(await Promise.allSettled(t.map((async e=>({quote:await H({isTestnet:!!xe.testnet,input:U({amount:He.toString(),user:Ue.address,recipient:Be,destinationChainId:xe.id,destinationCurrency:Le,originChainId:e.chain.id})}),...e}))))).filter((e=>"fulfilled"===e.status)).map((e=>e.value));if(n.length<1)return void le(new C(`Wallet ${O(Ue.address)} does not have enough funds.`,void 0,T.INSUFFICIENT_BALANCE));let i=n.map((e=>({bridgeTx:W(e.quote),balance:e.balance,chain:e.chain}))).filter((e=>!!e.bridgeTx));if(i.length>1)return void he(i);let r=i[0];r?(be(!0),Ve({data:r.bridgeTx.data,to:r.bridgeTx.to,value:r.bridgeTx.value,chain:r.chain})):le(new C(`Wallet ${O(Ue.address)} does not have enough funds.`,void 0,T.INSUFFICIENT_BALANCE))})().catch(console.error)}),[ae]),_({transactionHash:Se,wallet:Ue,isTestnet:!!xe.testnet,bridgingStatus:Ne,setBridgingStatus:Ae,onSuccess({transactionHash:e,wallet:o}){be(!1),Te(!0),Z({eventName:R,payload:{provider:"external",status:"success",txHash:e,address:o.address,chainId:Ge.chain.id,chainType:"ethereum",value:Ge.value?u(BigInt(Ge.value),Ee?.decimals??18):void 0,token:Ee?.symbol??Le??"ETH",destinationAddress:Be,destinationChainId:xe.id,destinationChainType:"ethereum",destinationValue:He?u(He,Ee?.decimals??18):void 0,destinationToken:Ee?.symbol??Le??xe.nativeCurrency.name}})},onFailure({error:e}){be(!1),le(e)}}),r((()=>{if(!me)return;let e={error:me,previousScreen:D.FUNDING_TRANSFER_FROM_WALLET_SCREEN};K({funding:oe?.funding,sendTransaction:oe?.sendTransaction,errorModalData:e}),J(D.ERROR_SCREEN,!1)}),[me]);let Qe=Ue?P(Ue.walletClientType,Ue.connectorType,Ue.walletClientType)||"wallet":null,Xe=!Re&&De?F(Me??"0",De):void 0,Ye=Re?re:B([re,He]),Ze=Ye&&De?L(Ye,De):void 0,Je=Ye?M(Ye,"ETH"):void 0,Ke=re&&De?L(re,De):void 0,eo=re?M(re,"ETH"):void 0;if(r((()=>{if(!Ce)return;let e=setTimeout(Y,I);return()=>clearTimeout(e)}),[Ce]),Ce/*#__PURE__*/)return e(o,{children:[/*#__PURE__*/t(y,{}),/*#__PURE__*/t(h,{}),/*#__PURE__*/e(g,{children:[/*#__PURE__*/t(n,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),/*#__PURE__*/t(v,{title:"Success!",description:`You’ve successfully added ${Me} ${Re?Ee.symbol:xe.nativeCurrency.symbol} to your ${ee.name} wallet. It may take a minute before the funds are available to use.`})]}),/*#__PURE__*/t(j,{}),/*#__PURE__*/t(f,{})]});let oo=Re?`${x({amount:Oe,decimals:Ee.decimals})}  ${Ee.symbol}`:M(qe,xe.nativeCurrency.symbol,3,!0),to=ue[ge];return ue.length>1&&to?/*#__PURE__*/t(G,{displayName:Qe,configuredFundingChain:xe,formattedBalance:oo,fundingAmount:Me,fundingCurrency:Re?Ee.symbol:xe.nativeCurrency.symbol,fundingAmountInUsd:Xe,options:ue,selectedOption:to,isPreparing:fe,isSubmitting:we,addressToFund:Be,fundingWalletAddress:Ue?.address||"",errorMessage:de,onSubmit:()=>{oe.funding?.amount!==Me?async function(){if(Ue&&to)try{let e=await H({isTestnet:!!xe.testnet,input:U({amount:He.toString(),user:Ue.address,recipient:Be,destinationChainId:xe.id,destinationCurrency:Le,originChainId:to.chain.id})}),o=W(e);if(!o)throw Error("Invalid transaction request");be(!0),Ve({data:o.data,to:o.to,value:o.value,chain:to.chain})}catch(e){console.error(e),le(new C("Unable to fetch quotes for bridging",e,T.INSUFFICIENT_BALANCE))}}().catch(console.error):Ve({to:to.bridgeTx.to,data:to.bridgeTx.data,value:to.bridgeTx.value,chain:to.chain})},onSelect:e=>{e!==ge&&(pe(null),je(e))},onAmountChange:Pe}):ne&&re&&Ue&&oe?.funding?/*#__PURE__*/t(V,{wallet:Ue,displayName:Qe,addressToFund:Be,isBridging:ye,isErc20Flow:Re,totalPriceInUsd:Ze,totalPriceInNativeCurrency:Je,gasPriceInUsd:Ke,gasPriceInNativeCurrency:eo,chainId:xe.id,chainName:xe.name}):
/*#__PURE__*/e(o,{children:[/*#__PURE__*/t(y,{}),/*#__PURE__*/t(b,{}),/*#__PURE__*/t("div",{style:{marginTop:"1rem"}}),/*#__PURE__*/t(f,{})]})};export{Q as AwaitingExternalTransferScreen};

import{getAddress as e,toHex as t}from"viem/utils";import{getPrivyWalletKey as i,DEFAULT_NETWORK as n}from"../../constants.mjs";import{PrivyConnectorError as r}from"../../errors.mjs";import s from"../../storage.mjs";import{formatChainIdToCAIP2 as o,sleep as a,invokeUntilSettled as c}from"../../utils/index.mjs";import{areWalletArraysEqual as h}from"../areWalletArraysEqual.mjs";import{WalletConnector as l}from"../base.mjs";import{getRpcTimeout as d}from"../getRpcTimeout.mjs";import"ofetch";import"../get-legacy-injected-providers.mjs";import"../is-wallet-installed.mjs";import"../../utils/eth/getPublicClient.mjs";import"viem";import"../isBaseConnectedEthereumWallet.mjs";import"eventemitter3";function u(e){return"ethereum"===e.chainType}class m extends l{buildConnectedWallet(t,i,n,s){let c=async()=>!!this.wallets.find((i=>e(i.address)===e(t)));return{type:"ethereum",address:e(t),chainId:i,meta:n,imported:s,switchChain:async n=>{let s,h;if(!c)throw new r("Wallet is not currently connected.");let l=this.wallets.find((i=>e(i.address)===e(t)))?.chainId;if(!l)throw new r("Unable to determine current chainId.");if("number"==typeof n?(s=`0x${n.toString(16)}`,h=n):(s=n,h=Number(n)),l===o(s))return;let d=this.chains.find((e=>e.id===h));if(!d)throw new r(`Unsupported chainId: ${n}`);let u=async()=>{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:s}]})};try{return await u()}catch(e){if(((e,t)=>{switch(t){case"coinbase_wallet":return e.message.includes("addEthereumChain");case"rabby_wallet":return e.message.includes("Unrecognized chain ID");default:return 4902===e.code||e.message?.includes("4902")}})(e,this.walletClientType))return"rabby_wallet"===this.walletClientType&&await a(300),await this.proxyProvider.request({method:"wallet_addEthereumChain",params:[{chainId:s,chainName:d.name,nativeCurrency:d.nativeCurrency,rpcUrls:[d.rpcUrls.default?.http[0]??""],blockExplorerUrls:[d.blockExplorers?.default.url??""]}]}),u();if("rainbow"===this.walletClientType&&e.message?.includes("wallet_switchEthereumChain"))throw new r(`Rainbow does not support the chainId ${i}`);throw e}},connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:c,getEthereumProvider:async()=>{if(!await c())throw new r("Wallet is not currently connected.");return this.proxyProvider},sign:async e=>{if(!await c())throw new r("Wallet is not currently connected.");return await this.sign(e)},disconnect:()=>{this.disconnect()}}}async syncAccounts(t){let r,a=t;try{if(void 0===a){let e=await c((()=>this.proxyProvider.request({method:"eth_accounts"})),{maxAttempts:10,delayMs:500});console.debug(`eth_accounts for ${this.walletClientType}:`,e),Array.isArray(e)&&(a=e)}}catch(e){console.debug("Wallet did not respond to eth_accounts. Defaulting to prefetched accounts.",e)}if(!a||!Array.isArray(a)||a.length<=0||!a[0])return;let l=a[0],d=e(l),u=[];if("privy"===this.walletClientType){let e=s.get(i(d));this.chains.find((t=>t.id===Number(e)))||(s.del(i(d)),e=null),r=e||`0x${this.defaultChain.id.toString(16)}`;try{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:r}]})}catch(e){console.warn(`Unable to switch embedded wallet to chain ID ${r} on initialization`)}}else try{let e=await c((()=>this.proxyProvider.request({method:"eth_chainId"})),{maxAttempts:10,delayMs:500});if(console.debug(`eth_chainId for ${this.walletClientType}:`,e),"string"==typeof e)r=e;else{if("number"!=typeof e)throw Error("Invalid chainId returned from provider");r=`0x${e.toString(16)}`}}catch(e){console.warn(`Failed to get chainId from provider, defaulting to ${n}`,e),r=n}let m=o(r);if(!u.find((t=>e(t.address)===d))){let t={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};u.push(this.buildConnectedWallet(e(l),m,t,"embedded_imported"===this.connectorType))}h(u,this.wallets)||(this.wallets=u,this.emit("walletsUpdated"))}async getConnectedWallet(){let t=await this.proxyProvider.request({method:"eth_accounts"});return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt)).find((i=>t.find((t=>e(t)===e(i.address)))))||null}async isConnected(){let e=await this.proxyProvider.request({method:"eth_accounts"});return Array.isArray(e)&&e.length>0}async sign(e){return await this.connect({showPrompt:!1}),this.proxyProvider.request({method:"personal_sign",params:[t(e),this.wallets[0]?.address]})}subscribeListeners(){this.proxyProvider.on("accountsChanged",this.onAccountsChanged),this.proxyProvider.on("chainChanged",this.onChainChanged),this.proxyProvider.on("disconnect",this.onDisconnect),this.proxyProvider.on("connect",this.onConnect)}unsubscribeListeners(){this.proxyProvider.removeListener("accountsChanged",this.onAccountsChanged),this.proxyProvider.removeListener("chainChanged",this.onChainChanged),this.proxyProvider.removeListener("disconnect",this.onDisconnect),this.proxyProvider.removeListener("connect",this.onConnect)}constructor(e,t,n,r){super(e),this.chainType="ethereum",this.onAccountsChanged=e=>{0===e.length?this.onDisconnect():this.syncAccounts(e)},this.onChainChanged=e=>{this.wallets.forEach((t=>{t.chainId=o(e),"privy"===this.walletClientType&&s.put(i(t.address),e)})),this.emit("walletsUpdated")},this.onDisconnect=()=>{this.connected=!1,this.wallets=[],this.emit("walletsUpdated")},this.onConnect=()=>{this.connected=!0,this.syncAccounts()},this.wallets=[],this.walletClientType=e,this.chains=t,this.defaultChain=n,this.rpcConfig=r,this.rpcTimeoutDuration=d(r,e),this.connected=!1,this.initialized=!1}}export{m as EthereumWalletConnector,u as isEthereumWalletConnector};

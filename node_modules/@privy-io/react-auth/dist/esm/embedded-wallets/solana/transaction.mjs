import{getWalletPublicKeyFromTransaction as e,isVersionedTransaction as a}from"../../lib/solana/transaction.mjs";import"../../lib/solana/index.mjs";import"../../utils/buffer/readBigInt64LE.mjs";import"../../lib/attempt.mjs";async function t({tx:t,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l}){let c=e(t,o),d=a(t)?Buffer.from(t.message.serialize()):t.serializeMessage(),{response:p}=await n.rpc({accessToken:r,entropyId:s,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:l,request:{method:"signMessage",params:{message:d.toString("base64")}}}),g=p.data.signature,f=Buffer.from(g,"base64");t.addSignature(c,f)}async function r({tx:e,connection:a,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l,transactionOptions:c}){let d;try{await t({tx:e,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l});let p=e.serialize();d=await a.sendRawTransaction(p,c);let g=await a.confirmTransaction(d);if(g.value.err||g.value.err){let e=g.value.err||g.value.err;if("string"==typeof e)throw Error(e);throw e}return{signature:d,signedTransaction:e,receipt:await a.getParsedTransaction(d,{maxSupportedTransactionVersion:0})}}catch(e){throw e.txSignature=d,e}}export{r as sendSolanaTransaction,t as signSolanaTransaction};

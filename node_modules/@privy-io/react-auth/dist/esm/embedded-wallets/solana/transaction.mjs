import{getWalletPublicKeyFromTransaction as e,isVersionedTransaction as t}from"../../lib/solana/transaction.mjs";import"../../lib/solana/index.mjs";import"../../utils/buffer/readBigInt64LE.mjs";import"../../lib/attempt.mjs";async function a({tx:a,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l}){let c=e(a,o),d=t(a)?Buffer.from(a.message.serialize()):a.serializeMessage(),{response:p}=await n.rpc({accessToken:r,entropyId:s,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:l,request:{method:"signMessage",params:{message:d.toString("base64")}}}),f=p.data.signature;a.addSignature(c,Buffer.from(f,"base64"))}async function r({tx:e,connection:t,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l,transactionOptions:c}){let d;try{await a({tx:e,accessToken:r,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l});let p=e.serialize();d=await t.sendRawTransaction(p,c);let f=await t.confirmTransaction(d);if(f.value.err||f.value.err){let e=f.value.err||f.value.err;if("string"==typeof e)throw Error(e);throw e}return{signature:d,receipt:await t.getParsedTransaction(d,{maxSupportedTransactionVersion:0})}}catch(e){throw e.txSignature=d,e}}export{r as sendSolanaTransaction,a as signSolanaTransaction};

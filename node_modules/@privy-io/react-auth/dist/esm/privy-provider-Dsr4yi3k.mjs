import{jsx as e,jsxs as t}from"react/jsx-runtime";import{createStore as a}from"mipd";import{useState as r,useRef as n,useEffect as i,useMemo as o}from"react";import{isAndroid as s}from"react-device-detect";import{getAddress as l}from"viem/utils";import{CustomJwtAccountFlow as c}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as d,EmailFlow as u}from"./auth-flows/email.mjs";import{FarcasterFlow as h}from"./auth-flows/farcaster.mjs";import{GuestFlow as p}from"./auth-flows/guest.mjs";import{PasskeyFlow as w}from"./auth-flows/passkey.mjs";import{SiweFlow as m}from"./auth-flows/siwe.mjs";import{SiwsFlow as y}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as g,SmsFlow as f}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as E,convertInitDataRawToTelegramWebAppData as A,detectCompletingTelegramFlow as _}from"./auth-flows/telegram.mjs";import{v4 as T}from"uuid";import{AccessToken as v}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as C,convertUserResponseToUser as I,getPrivySolanaHDWallets as k,getImportedPrivySolanaWallet as W,getPrivyPrimaryWallet as N,getPrivyEthereumWallet as U,getPrivyEthereumHDWallets as b,getImportedPrivyEthereumWallet as O,getPrivySolanaWallet as S,getLatestPrivyEthereumWallet as R,getSolanaSigningAndRootWallet as D,getEthereumSigningAndRootWallet as P,getLatestPrivySolanaWallet as M,getEntropyDetailsFromUser as L}from"./client/user.mjs";import F from"eventemitter3";import{CONNECTORS_STATE_KEY as x,CONNECTIONS_HISTORY_KEY as j,DEFAULT_PRIVY_API_URL as B,DEFAULT_API_TIMEOUT_MS as V,CLIENT_ANALYTICS_ID_KEY as H,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as K,PRIVY_ACCESS_TOKEN_STORAGE_KEY as z,getGuestCredentialStorageKey as G,WALLET_PROXY_TIMEOUT as q,HEADLESS_OAUTH_KEY as $,OAUTH_DISABLE_SIGNUP_KEY as Y,STATE_CODE_KEY as X,FORKED_TOKEN_STORAGE_KEY as Q}from"./constants.mjs";import J,{isLocalStorageAccessible as Z}from"./storage.mjs";import{generateTypedDataWithDomainType as ee,toHex as te,detectInjectedConnectors as ae,formatChainIdToCAIP2 as re}from"./utils/index.mjs";import{CoinbaseWalletConnector as ne}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as ie}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as oe}from"./embedded-wallets/rpc/types.mjs";import{Captcha as se}from"./components/Captcha.mjs";import{LoginModal as le}from"./components/LoginModal.mjs";import{TelegramLoginButton as ce}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as de,useAppConfig as ue,useIsServerConfigLoaded as he}from"./configuration/context.mjs";import{areWalletArraysEqual as pe}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as we}from"./connectors/errors.mjs";import{isBaseConnectedEthereumWallet as me}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{mobileWalletsConfig as ye,getWalletConfigForConnector as ge}from"./connectors/mobile-wallets.mjs";import{isSolanaWalletConnector as fe,isBaseConnectedSolanaWallet as Ee}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as Ae}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as _e}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Te,getDelegatedWalletsData as ve,getRootWalletDataForDelegation as Ce,getDelegatedWalletsForUser as Ie}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as ke}from"./embedded-wallets/errors.mjs";import{signTransaction as We,sendTransaction as Ne}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as Ue,formatApiError as be,formatPrivyError as Oe,PrivyErrorCode as Se,PrivyNotReadyError as Re,PrivyConnectorError as De,PrivyError as Pe}from"./errors.mjs";import{signSolanaTransaction as Me,sendSolanaTransaction as Le}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as Fe}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as xe,isPrivyTheOAuthProvider as je,CROSS_APP_BROADCAST_CHANNEL_NAME as Be}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Ve,authenticateCrossAppAccount as He,getProviderAppMetadata as Ke}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as ze}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as Ge}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as qe,authenticateRecovery as $e,embeddedWalletRecoveryScreen as Ye,toEmbeddedWalletSetRecoveryScreen as Xe}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as Qe,fundingScreenMethodMap as Je}from"./lib/funding/index.mjs";import{isFundingEnabled as Ze}from"./lib/funding/isFundingEnabled.mjs";import et from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as tt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as at}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as rt}from"./lib/siwe.mjs";import{hasSufficientFunds as nt,createSolanaTransactionReceipt as it}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as ot}from"./lib/toDisplayFromAccountType.mjs";import{shouldCreateEmbeddedEthWallet as st}from"./lib/user/shouldCreateEmbeddedEthWallet.mjs";import{shouldCreateEmbeddedSolWallet as lt}from"./lib/user/shouldCreateEmbeddedSolWallet.mjs";import{prepareTransactionRequest as ct}from"./lib/viem/prepareTransactionRequest.mjs";import{transformResponseToSnakeCase as dt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ut,usePlugins as ht}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as pt}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as wt}from"./recent-login/context.mjs";import{ModalScreen as mt}from"./screens/index.mjs";import{Hide as yt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as gt}from"./styles.mjs";import{getPublicClient as ft}from"./utils/eth/getPublicClient.mjs";import{notImplemented as Et}from"./hooks/index.mjs";import{CaptchaProvider as At}from"./hooks/captcha-context.mjs";import{privyEventsDefault as _t,emitPrivyEvent as Tt,PrivyEventsContext as vt}from"./hooks/events-context.mjs";import{InternalPrivyContext as Ct}from"./hooks/internal-context.mjs";import{ModalProvider as It}from"./hooks/modal-context.mjs";import{PrivyContext as kt}from"./hooks/privy-context.mjs";import{UseWalletsContext as Wt}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as Nt,prepareFundingModalData as Ut}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as bt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{OAuthFlow as Ot}from"./auth-flows/oauth/OAuthFlow.mjs";import{toViemTransactionSerializable as St}from"./lib/viem/toViemTransactionSerializable.mjs";import{getRpcTimeout as Rt}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as Dt}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as Pt}from"./connectors/ethereum/index.mjs";import{EthereumNullConnector as Mt}from"./connectors/ethereum/EthereumNullConnector.mjs";import{LegacyInjectedWalletConnector as Lt,Injected6963WalletConnector as Ft}from"./connectors/injected.mjs";import{MetamaskWalletConnector as xt}from"./connectors/metamask.mjs";import{PrivyProxyProvider as jt}from"./connectors/privyProxyProvider.mjs";import{SolanaNullConnector as Bt}from"./connectors/solana/SolanaNullConnector.mjs";import{loadConnectionHistory as Vt}from"./connectors/stored-connection.mjs";import{Http as Ht}from"./http.mjs";import{getPaymasterContext as Kt}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as zt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as Gt,mfaPasskeyInitPath as qt,acceptTermsPath as $t,unlinkEmailPath as Yt,unlinkPhonePath as Xt,unlinkWalletPath as Qt,siwsUnlinkWalletPath as Jt,unlinkOAuthPath as Zt,unlinkFarcasterPath as ea,telegramAccountUnlinkPath as ta,delegatedActionsRevokePath as aa,analyticsEventsPath as ra,moonpayPluginOnRampPath as na,coinbaseOnRampInitPath as ia,coinbaseOnRampStatusPath as oa,siweInitPath as sa,siweAuthenticatePath as la,siweLinkPath as ca,smartWalletLinkPath as da,siwsInitPath as ua,siwsAuthenticatePath as ha,transferOAuthPath as pa,telegramAccountTransferPath as wa,transferFarcasterPath as ma,transferWalletPath as ya,transferPhonePath as ga,transferEmailPath as fa,siwsLinkPath as Ea,usersMePath as Aa,transactionScanningPath as _a}from"./paths.mjs";import{AccessTokenTypes as Ta,Session as va}from"./session.mjs";class Ca extends F{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Dt(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Ba()||!this.address)throw new Dt("Disconnected",4900);let{hash:a}=await za(t,{address:this.address});return a}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Dt(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Ba()||!this.address)throw new Dt("Disconnected",4900);let{signature:a}=await Ka(t,{address:this.address});return a}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Dt(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Dt(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=ft(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],a=e.params[1],{signature:r}=await Va({message:t},{address:a});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],a="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await Ha(ee(a),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:te(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...St(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return te(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!oe(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await Ba();if(await Ga(),!t||!this.address)throw new Dt("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Dt("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:a,entropyIdVerifier:r,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=a,this.entropyIdVerifier=r,this.chainId=s,this.rpcConfig=n,this.chains=i,this.publicClient=ft(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Rt(n,"privy"),this.appId=o,this.walletIndex=l}}class Ia extends F{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let a=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(a)&&(e.add(a),!0)})),a=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return a>=0&&t.unshift(t.splice(a,1)[0]),t}async initialize(e){if(this.initialized&&!e)return;e&&this.removeAllConnectors(),J.get(x)&&(J.getKeys().forEach((e=>{e.startsWith("walletconnect")&&J.del(e)})),J.del(x));let t=ae({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:a})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:a}})}))}));for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),Object.values(ye)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addWalletConnector(new Bt({id:e.client,name:e.name,icon:e.logoDataUri})));this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"}),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(Pt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(Pt).find((a=>a.connectorType===e&&a.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(fe).find((a=>a.connectorType===e&&("unknown"===a.walletClientType?a.walletBranding.id===t:a.walletClientType===t)))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:a,defaultChain:r,appId:n}){for(let i of a){let a=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(a&&Pt(a))a.proxyProvider.walletProxy=e;else{let{entropyId:a,entropyIdVerifier:o}=C(t),s=new ie({provider:new Ca({walletProxy:e,address:i.address,entropyId:a,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:r.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,a,r){let n=this.findWalletConnector("embedded_imported","privy");if(n&&Pt(n))n.proxyProvider.walletProxy=e;else{let n=new ie({provider:new Ca({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:a.id}),chains:this.chains,walletIndex:0,defaultChain:a,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=Vt(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=Vt(),this.emit("walletsUpdated")}}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:a,walletConfig:r}){let n=this.findWalletConnector(e,t);if(n&&Pt(n))return n instanceof Ae&&n.resetConnection(t),n;let i=(()=>"injected"!==e?"coinbase_wallet"===e?new ne(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"null"!==e?new Ae(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):r?new Mt({id:r.client,name:r.name,icon:r.logoDataUri,defaultChain:this.defaultChain,walletClientType:r.client}):null:"metamask"===t&&a?.eip6963InjectedProvider?new xt(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,"metamask"):"metamask"===t&&a?.legacyInjectedProvider?new Lt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"metamask"):"phantom"===t&&a?.legacyInjectedProvider?new Lt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"phantom"):a?.legacyInjectedProvider&&"unknown_browser_extension"===t?new Lt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider):a?.eip6963InjectedProvider?new Ft(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,t):void 0)();return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));J.put(j,e)}async activeWalletSign(e){let t=this.wallets,a=t.length>0?t[0]:null;return a&&me(a)?a.sign(e):null}setActiveWallet(e){this.activeWallet=l(e),this.emit("walletsUpdated")}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,a,r,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new jt},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=a,this.chains=r,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=Vt()}}let ka;var Wa=0,Na="__private_"+Wa+++"__getOrGenerateClientAnalyticsId";class Ua{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:a,defaultChain:r,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new Ia(this.appId,e,t,a,r,n,i,o,s,l,void 0,c))}generateApi(){let e=new Ht({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Ue("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Ue("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(Gt,{action:"verify"})}catch(e){throw be(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(qt,{});return zt(e.options)}catch(e){throw be(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post($t,{});return I(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(Yt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(Xt,{phoneNumber:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(Qt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(Jt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let a=await this.api.post(Zt,{provider:e,subject:t});return await this.getAuthenticatedUser()??I(a)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(ea,{fid:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ta,{telegram_user_id:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(aa,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:a,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(ra,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:a?a.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(na,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(ia,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${oa}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(Ta.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(Ta.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?v.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return a.enabled?{enabled:a.enabled,smartWalletType:a.smart_wallet_type,configuredNetworks:a.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:Kt(e.paymaster_url,e.paymaster_context)})))}:{enabled:a.enabled}}catch(e){throw Oe(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),r=a.telegram_auth_config?{botId:a.telegram_auth_config.bot_id,botName:a.telegram_auth_config.bot_name,linkEnabled:a.telegram_auth_config.link_enabled,seamlessAuthEnabled:a.telegram_auth_config.seamless_auth_enabled}:void 0,n=a.funding_config?{methods:a.funding_config.methods,options:a.funding_config.options,defaultRecommendedAmount:a.funding_config.default_recommended_amount,defaultRecommendedCurrency:a.funding_config.default_recommended_currency,promptFundingOnWalletCreation:a.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:a.funding_config.cross_chain_bridging_enabled}:void 0;return{id:a.id,name:a.name,verificationKey:a.verification_key,logoUrl:a.logo_url||void 0,accentColor:a.accent_color||void 0,showWalletLoginFirst:a.show_wallet_login_first,allowlistConfig:{errorTitle:a.allowlist_config.error_title,errorDetail:a.allowlist_config.error_detail,errorCtaText:a.allowlist_config.cta_text,errorCtaLink:a.allowlist_config.cta_link},walletAuth:a.wallet_auth,solanaWalletAuth:a.solana_wallet_auth,emailAuth:a.email_auth,smsAuth:a.sms_auth,googleOAuth:a.google_oauth,twitterOAuth:a.twitter_oauth,discordOAuth:a.discord_oauth,githubOAuth:a.github_oauth,spotifyOAuth:a.spotify_oauth,instagramOAuth:a.instagram_oauth,tiktokOAuth:a.tiktok_oauth,linkedinOAuth:a.linkedin_oauth,appleOAuth:a.apple_oauth,farcasterAuth:a.farcaster_auth,passkeyAuth:a.passkey_auth,passkeysForSignupEnabled:a.passkeys_for_signup_enabled,telegramAuth:a.telegram_auth,disablePlusEmails:a.disable_plus_emails,termsAndConditionsUrl:a.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:a.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:a.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:a.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:a.privacy_policy_url,requireUsersAcceptTerms:a.require_users_accept_terms,customApiUrl:a.custom_api_url,walletConnectCloudProjectId:a.wallet_connect_cloud_project_id,fiatOnRampEnabled:a.fiat_on_ramp_enabled,captchaEnabled:a.captcha_enabled,captchaSiteKey:a.captcha_site_key,createdAt:new Date(1e3*a.created_at),updatedAt:new Date(1e3*a.updated_at),mfaMethods:a.mfa_methods,enforceWalletUis:a.enforce_wallet_uis,legacyWalletUiConfig:a.legacy_wallet_ui_config,telegramAuthConfiguration:r,fundingConfig:n}}catch(e){throw Oe(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(a){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(sa,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i}){return await this.api.post(la,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){return await this.api.post(ca,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:a}){try{let r=await this.api.post(da,{message:e,signature:t,smart_wallet_type:a});return I(r)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n});return I(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(ua,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r,mode:n}){return await this.api.post(ha,{message:e,signature:t,walletClientType:a,connectorType:r,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s}){try{let l,c;switch(a){case"email":l=fa,c={nonce:e,email:t};break;case"sms":l=ga,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=ya,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=ma,c={nonce:e,farcaster_id:t,farcaster_embedded_address:o};break;case"telegram":l=wa,c={nonce:e,telegram_auth_result:n,telegram_web_app_data:i};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=pa,c={nonce:e,userInfo:s}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??I(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r}){return await this.api.post(Ea,{message:e,signature:t,walletClientType:a,connectorType:r})}async linkWithSiws({message:e,signature:t,walletClientType:a,connectorType:r}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r});return I(n)}catch(e){throw Oe(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(Aa);return this.session.updateIdentityToken(e.identity_token),I(e.user)}catch(e){throw Oe(e)}}async scanTransaction(e){try{return await this.api.post(_a,e)}catch(e){throw Oe(e)}}constructor({apiUrl:e=B,appId:t,appClientId:a,timeout:r=V}){Object.defineProperty(this,Na,{value:ba}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==B&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=a,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Na)[Na](),ka||(ka=new va),this.session=ka,this.api=this.generateApi(),this.session.client=this}}function ba(){if("undefined"==typeof window)return null;try{let e=J.get(H);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=T();try{return J.put(H,e),e}catch(t){return e}}class Oa{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await $a({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Ba())throw Error("User must be authenticated to use embedded Solana wallet");if(!await qa())throw new Ue("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let Sa,Ra,Da,Pa,Ma,La,Fa,xa;function ja(){return Sa?Sa.getCustomerAccessToken():Promise.resolve(J.get(K)||null)}async function Ba(){return Sa?Sa.getAccessToken():Promise.resolve(J.get(z)||J.get(K)||null)}const Va=(e,t)=>Ra(e,t),Ha=(e,t)=>Da(e,t),Ka=(e,t)=>Pa(e,t),za=(e,t)=>Ma(e,t),Ga=()=>La(),qa=()=>Fa(),$a=({message:e,address:t})=>xa({message:e,address:t});const Ya=({config:t,...a})=>{var r;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new Ue("Embedded wallet is only available over HTTPS");if("string"!=typeof(r=a.appId)||25!==r.length)throw new Ue("Cannot initialize the Privy provider with an invalid Privy app ID");Sa||(Sa=new Ua({appId:a.appId,appClientId:a.clientId,apiUrl:a.apiUrl}));let n=Object.assign({},t);/*#__PURE__*/
return e(de,{client:Sa,clientConfig:n,children:/*#__PURE__*/e(ut,{children:/*#__PURE__*/e(Xa,{...a,client:Sa})})})};let Xa=T=>{let v=T.client,I=ht(),[F,x]=r(!1),[j,V]=r(!1),[K,z]=r(!1),[ae,ne]=r(null),[ie,oe]=r([]),[de,ye]=r([]),[fe,be]=r([]),[Oe,ut]=r(!1),[St,Rt]=r(null),[Dt,Pt]=r(!1),[Mt,Lt]=r({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Et}),[Ft,xt]=r({status:"initial"}),[jt,Bt]=r({status:"initial"}),[Vt,Ht]=r({status:"initial"}),[Kt,zt]=r({status:"initial"}),[Gt,qt]=r({status:"initial"}),[$t,Yt]=r(null),Xt=ue(),Qt=he(),[Jt,Zt]=r(!0),[ea,ta]=r({}),[aa,ra]=r(null),[na,ia]=r(null),[oa,sa]=r(!1),[la,ca]=r(!1),[da,ua]=r(Xt.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),ha=n(null),pa=n(null),wa=n(_t),[ma,ya]=r(!1);v.onStoreCustomerAccessToken=e=>{e&&Tt(wa,"accessToken","onAccessTokenGranted",{accessToken:e})},v.onDeleteCustomerAccessToken=()=>{ne(null),z(!1),Tt(wa,"accessToken","onAccessTokenRemoved")};let ga=n(null),fa=n(null),Ea=n(!1),Aa=({showWalletUIs:e})=>Ea.current?Ea.current:void 0!==e?!e:!Xt.embeddedWallets.showWalletUIs,_a=e=>{Rt(e),setTimeout((()=>{x(!0)}),15),v.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},Ta=e=>{("off"!==Xt.embeddedWallets.ethereum.createOnLogin||"off"!==Xt.embeddedWallets.solana.createOnLogin)&&Zt(!0),_a(e)};i((()=>{let e=[...k(ae),W(ae)].filter((e=>!!e));$t&&be(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new Ue("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new Ue("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Oa($t,e.address),async signMessage(t){let a=await Ba();if(!a||!$t)throw new Ue("Must have valid access token and Privy wallet to send transaction",Se.MUST_BE_AUTHENTICATED);let r=e.imported?W(ae):N(ae);if(!r)throw new Ue("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=C(r);if(!await nr.recoverPrimaryWallet().catch((()=>!1)))throw new Ue("Wallet couldn't be connected",Se.UNKNOWN_CONNECT_WALLET_ERROR);if(!ae)throw new Ue("Attempting to sign a transaction with no user initialized");let{response:o}=await $t.rpc({accessToken:a,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:e.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,a){let{signature:r}=await Qa({transaction:e,connection:t,transactionOptions:a,wallet:this});return r},async signTransaction(t){let a=await Ba();if(!a||!$t)throw new Ue("Must have valid access token and Privy wallet to send transaction",Se.MUST_BE_AUTHENTICATED);if(!await nr.recoverPrimaryWallet().catch((()=>!1)))throw new Ue("Wallet couldn't be connected",Se.UNKNOWN_CONNECT_WALLET_ERROR);let r=e.imported?e:N(ae);if(!r)throw new Ue("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=C(r);return await Me({tx:t,accessToken:a,walletProxy:$t,entropyId:n,entropyIdVerifier:i,transactingWalletAddress:e.address,transactingWalletIndex:e.walletIndex??0}),t},loginOrLink:async()=>{throw new Ue("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[$t,ae]),i((()=>{if(!ae)return void v.connectors?.removeEmbeddedWalletConnectors();let e=U(ae),t=b(ae),a=O(ae);e&&t.length||v.connectors?.removeEmbeddedWalletConnectors(),a||v.connectors?.removeImportedWalletConnector(),v.connectors?$t?(e&&v.connectors.addEmbeddedWalletConnectors({walletProxy:$t,rootWallet:e,embeddedWallets:t,defaultChain:Xt.defaultChain,appId:T.appId}),a&&v.connectors.addImportedWalletConnector($t,a.address,Xt.defaultChain,T.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[$t,ae]),i((()=>{$t&&na?.($t)}),[$t]);let va=n();i((()=>{(async()=>{if(!Xt.customAuth?.enabled)return void ua({status:"not-enabled"});Zt(!0);let{getCustomAccessToken:e,isLoading:t}=Xt.customAuth;if(j&&!t&&"loading"!==da.status){ua({status:"loading"});try{let t=await e();if(t===va.current)return void ua({status:"done"});if(!t&&K)return va.current=t,await rr.logout(),ua({status:"done"}),void Tt(wa,"customAuth","onUnauthenticated");if(!t)return va.current=t,void ua({status:"done"});v.startAuthFlow(new c(t));let{user:a,isNewUser:r}=await v.authenticate();if(!a)return await rr.logout(),ua({status:"error",error:new Ue("Failed to sync with custom auth provider")}),void Tt(wa,"customAuth","onUnauthenticated");void 0!==r&&Tt(wa,"login","onComplete",{user:a,isNewUser:r,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),va.current=t,Tt(wa,"customAuth","onAuthenticated",{user:a}),ua({status:"done"}),ne(a||null),ut(r||!1),z(!0),ca(!0)}catch(e){if(console.warn(e),await rr.logout(),Tt(wa,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void ua({status:"initial"});Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),ua({status:"error",error:e})}}})()}),["initial"===da.status,Xt.customAuth?.enabled,Xt.customAuth?.getCustomAccessToken,Xt.customAuth?.isLoading,j,K]),i((()=>{la&&$t&&ae&&(async()=>{let e=st(ae,Xt.embeddedWallets.ethereum.createOnLogin),t=lt(ae,Xt.embeddedWallets.solana.createOnLogin),a=await Ba();if(a){if(e&&t){let e=await za(ae,q);return await $t.createSolana({accessToken:a,ethereumAddress:e?.address}),void ca(!1)}if(t)return await $t.createSolana({accessToken:a,ethereumAddress:U(ae)?.address}),await nr.refreshSessionAndUser(),void ca(!1);if(e)return await za(ae,q),void ca(!1)}})().catch(console.error)}),[la&&$t&&ae]),i((()=>{if(Xt.externalWallets.solana.connectors)return Xt.externalWallets.solana.connectors.onMount(),()=>Xt.externalWallets.solana.connectors?.onUnmount()}),[Xt.externalWallets.solana.connectors]),i((()=>{!j&&Qt&&async function(){let e,t=Ca(),r=Ia();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;J.put(Q,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let n=a();v.initializeConnectorManager({walletConnectCloudProjectId:Xt.walletConnectCloudProjectId,rpcConfig:Xt.rpcConfig,chains:Xt.chains,defaultChain:Xt.defaultChain,store:n,walletList:Xt.appearance.walletList,shouldEnforceDefaultChainOnConnect:Xt.shouldEnforceDefaultChainOnConnect,externalWalletConfig:Xt.externalWallets,appName:Xt.name??"Privy",walletChainType:Xt.appearance.walletChainType}),v.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=v.connectors.walletConnectors.length,a=v.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);a===t?ya(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:a,expected:t}),ya(!0)}),1500)})),v.connectors?.initialize().then((()=>{ba()}));let i=await v.getAuthenticatedUser(),o=!!i;Xt.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await v.logout(),nr.setReadyToTrue(!0),Tt(wa,"logout","onSuccess")):(Xt.customAuth?.enabled||(z(!!i),i&&Tt(wa,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),ne(i)),t?fa.current=o?"link":"login":r&&!o?(fa.current="login",ta({telegramAuthModalData:{seamlessAuth:!0}}),Ta(mt.TELEGRAM_AUTH_SCREEN)):nr.setReadyToTrue(!!i))}()}),[v,aa,j,Qt]),i((()=>{if(j){if(!ae||!ae.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void sa(!0);sa([...ie,...fe].some((e=>"privy"===e.walletClientType)))}}),[j,ae,ie,fe]),i((()=>{v.connectors?.setWalletList(Xt.appearance.walletList)}),[Xt.appearance.walletList.join()]);let Ca=()=>{let e=bt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&je(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Be).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(v.startAuthFlow(new Ot(e)),Ta(mt.AWAITING_OAUTH_SCREEN),!0))},Ia=()=>{let e=_();if(!e||!Xt.loginMethods.telegram||!Xt.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new E;return v.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},ka=async(e,t,a,r)=>{if("solana_adapter"!==e)Wa(await(v.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,a,r);else{let n=v.connectors?.findSolanaWalletConnector(e,t);if(!n)return;Wa(n,t,a,r)}};async function Wa(e,t,a,r){if(!e)return Lt({status:"disconnected",connectedWallet:null,connectError:new De("Unable to connect to wallet."),connector:null,connectRetry:Et}),r?.(null,a);Lt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Et}),e instanceof Ae&&t&&await e.resetConnection(t),Lt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>Wa(e,t,a,r)});try{let t=await e.connect({showPrompt:!0});if((!t||me(t))&&Xt.shouldEnforceDefaultChainOnConnect&&!Xt.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Lt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Et})));try{await(t?.switchChain(Xt.defaultChain.id)),t&&(t.chainId=re(te(Xt.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${Xt.defaultChain.id}`)}}return Lt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Et}))),t&&Tt(wa,"connectWallet","onSuccess",{wallet:t}),r?.(t,a)}catch(e){return e instanceof Pe?(console.warn(e.cause?e.cause:e.message),Tt(wa,"connectWallet","onError",e.privyErrorCode||Se.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),Tt(wa,"connectWallet","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR)),Lt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,a)}}let Na=async(e,t,a)=>{if(null===e||!me(e))return;let r=new m(e,v,t,a);v.startAuthFlow(r)},Ua=async(e,t,a)=>{if(null===e||!Ee(e))return;let r=new y(e,v,t,a);v.startAuthFlow(r)},ba=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),a=e.get("privy_wallet_client"),r="true"===e.get("privy_connect_only");if(!t||!a)return;let n=ge({connectorType:t,walletClientType:a});if(!n||!n.isInstalled)return Ta(mt.LOGIN_FAILED_SCREEN);if(!v.connectors)throw new Ue("Connector not initialized");_a(r?mt.AWAITING_CONNECT_ONLY_CONNECTION:mt.AWAITING_CONNECTION);let i=new URL(window.location.href);i.searchParams.delete("privy_connector"),i.searchParams.delete("privy_wallet_client"),i.searchParams.delete("privy_connect_only"),window.history.pushState({},"",i),ka(t,a,void 0,r?void 0:"solana_adapter"===t?Ua:Na)};i((()=>{j&&K&&null===ae&&v.getAuthenticatedUser().then(ne)}),[j,K,ae,v]);let ja=e=>{if(!K)throw Tt(wa,"linkAccount","onError",Se.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Ue("User must be authenticated before linking an account.")},Va=e=>{if(!K||!ae)return!1;if("privy"===e.walletClientType)return!0;for(let t of ae.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Ha=async e=>{let t;if(!v.connectors)throw new Ue("Connector not initialized");t="ethereum"===e.type?v.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:v.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Lt((a=>({...a,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Et}))),Xt.captchaEnabled&&!K?(ta({captchaModalData:{callback:t=>me(e)?Na(e,t):Ua(e,t),userIntentRequired:!1,onSuccessNavigateTo:mt.AWAITING_CONNECTION,onErrorNavigateTo:mt.ERROR_SCREEN}}),Ta(mt.CAPTCHA_SCREEN)):(me(e)?await Na(e):await Ua(e),Ta(mt.AWAITING_CONNECTION))},Ka=()=>{oe((e=>{let t=v.connectors?.wallets.filter(me).map((e=>({...e,linked:Va(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Ue("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ue("Cannot link or login with embedded wallet");Ha(e)},fund:async t=>{await nr.fundWallet(e.address,t)},unlink:async()=>{if(!K)throw new Ue("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ue("Cannot unlink an embedded wallet");ne(await v.unlinkEthereumWallet(e.address))}})))||[];return pe(e,t)?e:t})),ye((e=>{let t=(v.connectors?.wallets??[]).filter(Ee).map((e=>({...e,linked:Va(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Ue("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ue("Cannot link or login with embedded wallet");Ha(e)},fund:async()=>{throw new Ue("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!K)throw new Ue("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ue("Cannot unlink an embedded wallet");ne(await v.unlinkSolanaWallet(e.address))}})));return pe(e,t)?e:t}))};i((()=>{Ka()}),[ae?.linkedAccounts,K,j]),i((()=>{if(j){if(!v.connectors)throw new Ue("Connector not initialized");Ka(),v.connectors.on("walletsUpdated",Ka)}}),[j]),i((()=>{[...Xt.loginMethodsAndOrder?.primary??[],...Xt.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>v.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!v]);let za=async(e,t,a)=>{let r=U(e),n=S(e);if(a&&"walletIndex"in a)return qa(e,t,a.walletIndex,r,n);let i=a&&"createAdditional"in a&&a.createAdditional;if(r&&!i)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([nr.initializeWalletProxy(t),Ba()]);if(!o&&Xt.customAuth?.enabled)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||Xt.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Ga();if(!r)return n&&await nr.recoverPrimaryWallet(),await o.create({accessToken:s,solanaAddress:n?.address}),Ya(0,"ethereum");{let t=(R(e)?.walletIndex??0)+1,{entropyId:a,entropyIdVerifier:r}=C(N(e));return await nr.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:a,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:t}),Ya(t,"ethereum")}},Ga=async()=>new Promise(((e,t)=>{Zt(!0),ta({createWallet:{onSuccess:t=>{Tt(wa,"createWallet","onSuccess",{wallet:t}),e(t)},onFailure:e=>{Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),_a(mt.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),qa=async(e,t,a,r,n)=>{if(a<0)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${a}) is invalid.`);let[i,o]=await Promise.all([nr.initializeWalletProxy(t),Ba()]);if(!i&&Xt.customAuth?.enabled)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||Xt.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==a)return Ga();throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==a){if(r)return r;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!r)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=b(e).find((e=>e.walletIndex===a));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=C(N(e));await nr.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:a})}return Ya(a,"ethereum")},$a=async({user:e,wp:t,accessToken:a,walletIndex:r,ethereumWallet:n})=>{let i=k(e).find((e=>e.walletIndex===r));if(i)return i;if(0===r)n&&await nr.recoverPrimaryWallet(),await t.createSolana({accessToken:a,ethereumAddress:n?.address});else{let n=N(e);if(!n)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=C(n);await nr.recoverPrimaryWallet(),await t.addWallet({accessToken:a,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:r})}return Ya(r,"solana")},Ya=async(e,t)=>{let a=await nr.refreshSessionAndUser(),r=("ethereum"===t?b(a):k(a)).find((t=>t.walletIndex===e));if(!r)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return Tt(wa,"createWallet","onSuccess",{wallet:r}),r},Xa=({transaction:e,uiOptions:t,fundWalletConfig:a,address:r,signOnly:n})=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{},c=n?"signTransaction":"sendTransaction";if(!K||!ae)return Tt(wa,c,"onError",Se.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let d=r??U(ae)?.address;if(!d)throw new Ue("User must have an embedded wallet to send a transaction.");let{signingWallet:u,rootWallet:h}=P(ae,d);if(!h||!u)return Tt(wa,c,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));Zt(!0);let p=ir.wallets.find((e=>"privy"===e.walletClientType&&l(e.address)===l(u.address))),w=await(p?.getEthereumProvider());if(!p||!w)throw new Ue(`Cannot sendTransaction before embedded wallet ${u.address} is connected`);let m=e.chainId?Number(e.chainId):Fe(p.chainId);(e=>{if(!Xt.chains.map((e=>e.id)).includes(e))throw new De(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Se.UNSUPPORTED_CHAIN_ID)})(m);let y={...e,from:e.from??u.address,chainId:m},g=await Ba();if(!g||!$t)return Tt(wa,c,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));let f=ft(y.chainId,Xt.chains,Xt.rpcConfig,{appId:T.appId});if(Aa({showWalletUIs:t?.showWalletUIs}))(async()=>{try{if(!await nr.recoverPrimaryWallet())return Tt(wa,c,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let e=await ct(y,f,y.from),{entropyId:t,entropyIdVerifier:a}=C(h),r=n?await We({accessToken:g,entropyId:t,entropyIdVerifier:a,transactingWallet:u,walletProxy:$t,transactionRequest:y,requesterAppId:s}):await Ne({accessToken:g,entropyId:t,entropyIdVerifier:a,transactingWallet:u,walletProxy:$t,transactionRequest:e,publicClient:f,requesterAppId:s});n?Tt(wa,"signTransaction","onSuccess",{signature:r}):Tt(wa,"sendTransaction","onSuccess",{hash:r}),i({hash:r})}catch(e){Tt(wa,c,"onError",Se.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:r}=C(h),l={entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{Tt(wa,c,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},d=Ze(Xt)?Ut({address:u.address,appConfig:Xt,fundWalletConfig:a,methodScreen:mt.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:y.chainId,comingFromSendTransactionScreen:!0}):void 0;ta({connectWallet:l,sendTransaction:{transactionRequest:y,transactingWallet:u,entropyId:e,entropyIdVerifier:r,signOnly:n,onConfirm:n?async()=>await We({accessToken:g,entropyId:e,entropyIdVerifier:r,transactingWallet:u,walletProxy:$t,transactionRequest:y,requesterAppId:s}):void 0,onSuccess:e=>{n?Tt(wa,"signTransaction","onSuccess",{signature:e.hash}):Tt(wa,"sendTransaction","onSuccess",{hash:e.hash}),i(e)},onFailure:e=>{Tt(wa,c,"onError",Se.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:a,requesterAppId:s},funding:d}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),Qa=({transaction:e,connection:t,transactionOptions:a,fundWalletConfig:r,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!K||!ae)return Tt(wa,"sendSolanaTransaction","onError",Se.MUST_BE_AUTHENTICATED),void s(new Ue("User must be authenticated before signing with a Privy wallet",Se.MUST_BE_AUTHENTICATED));let c=i?ae.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):S(ae);if(!c)return Tt(wa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void s(new Ue("Must have a Privy wallet before signing",Se.EMBEDDED_WALLET_NOT_FOUND));Zt(!0);let{rootWallet:d}=D(ae,c.address);if(!await nr.recoverPrimaryWallet().catch((()=>!1))||!d)throw Tt(wa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),new Ue(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Se.EMBEDDED_WALLET_NOT_FOUND);if(Aa({showWalletUIs:n?.showWalletUIs}))(async()=>{let r=await Ba();if(!r||!$t)return Tt(wa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void s(new Ue("Must have valid access token and Privy wallet to send transaction",Se.EMBEDDED_WALLET_NOT_FOUND));try{if(!await nr.recoverPrimaryWallet())return Tt(wa,"sendSolanaTransaction","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),void s(new Ue("Unable to connect to wallet",Se.UNKNOWN_CONNECT_WALLET_ERROR));if(Aa({showWalletUIs:n?.showWalletUIs}))try{if(!await nt(e,t))return Tt(wa,"sendSolanaTransaction","onError",Se.INSUFFICIENT_BALANCE),void s(new Ue("Solana wallet has insufficient funds for this transaction.",Se.INSUFFICIENT_BALANCE))}catch(e){return console.error(e),Tt(wa,"sendSolanaTransaction","onError",Se.TRANSACTION_FAILURE),void s(new Ue(e instanceof Error?e.message:"Transaction failed.",Se.TRANSACTION_FAILURE))}let{entropyId:i,entropyIdVerifier:l}=L(ae),{signature:d,receipt:u}=await Le({accessToken:r,tx:e,connection:t,walletProxy:$t,transactionOptions:a,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=it(d,u);Tt(wa,"sendSolanaTransaction","onSuccess",{response:h}),o(h)}catch(e){Tt(wa,"sendSolanaTransaction","onError",Se.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=C(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{Tt(wa,"sendSolanaTransaction","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},p=Ze(Xt)?Nt({address:c.address,appConfig:Xt,methodScreen:mt.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:r,comingFromSendTransactionScreen:!0}):void 0;ta({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:a,transactingWallet:c,onSuccess:e=>{Tt(wa,"sendSolanaTransaction","onSuccess",{response:e}),o(e)},onFailure:e=>{Tt(wa,"sendSolanaTransaction","onError",Se.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:p}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function Ja(){return new Promise((async(e,t)=>{let a=await Ba();if(!a||!$t)throw Error("Must have valid access token to enroll in MFA");try{await $t.verifyMfa({accessToken:a}),e()}catch(e){t(e)}}))}let Za=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],er=e=>{let t=ae?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:a,loginMethod:r}=ot(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw Tt(wa,"linkAccount","onError",Se.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Ue(`User already has an account of type ${a} linked.`)};async function tr({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){Rt(null);let a=t?"setWalletPassword":"setWalletRecovery";if(!K||!ae)throw Tt(wa,a,"onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=N(ae);if(!r||!$t)throw Tt(wa,a,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await Ja()}catch(e){throw Tt(wa,a,"onError",Se.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{Zt(!0);let o={onSuccess:e=>{Tt(wa,a,"onSuccess",{method:"user-passcode",wallet:e}),n(e)},onFailure:e=>{Tt(wa,a,"onError",Se.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===r.recoveryMethod,l=Xe({walletAction:"update",availableRecoveryMethods:Xt.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=C(r);ta({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{Tt(wa,a,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function ar({appId:e,action:t}){let a=await Ba();if("link"===t&&!a)throw Tt(wa,"linkAccount","onError",Se.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Ue("User must be authenticated before linking an account.");if("login"===t&&a)throw Tt(wa,"login","onError",Se.UNKNOWN_AUTH_ERROR),new Ue("Attempted to log in, but user is already logged in. Use a `link` helper instead.");ga.current=`privy:${e}`,fa.current=t;let r=tt();return v.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(a,n)=>{let{name:i,logoUrl:o}=await Ke({api:v.api,providerAppId:e,requesterAppId:Xt.id});ta({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:r,onSuccess:a,onError:n}}),Ta(mt.CROSS_APP_AUTH_SCREEN)}))}let rr={ready:j,authenticated:K,user:ae,walletConnectors:v.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),ta({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),_a(K?mt.CONNECT_ONLY_AUTHENTICATED_SCREEN:mt.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:()=>{ja("siwe"),ga.current="siwe",fa.current="link",_a(mt.LINK_WALLET_SCREEN)},startCrossAppAuthFlow:ar,linkEmail:()=>{ja("email"),er("email"),ga.current="email",fa.current="link",_a(mt.LINK_EMAIL_SCREEN)},linkPhone:()=>{ja("sms"),er("phone"),ga.current="sms",fa.current="link",_a(mt.LINK_PHONE_SCREEN)},linkGoogle:async()=>{ja("google"),er("google_oauth"),fa.current="link",await nr.initLoginWithOAuth("google")},linkTwitter:async()=>{ja("twitter"),er("twitter_oauth"),fa.current="link",await nr.initLoginWithOAuth("twitter")},linkDiscord:async()=>{ja("discord"),er("discord_oauth"),fa.current="link",await nr.initLoginWithOAuth("discord")},linkGithub:async()=>{ja("github"),er("github_oauth"),fa.current="link",await nr.initLoginWithOAuth("github")},linkSpotify:async()=>{ja("spotify"),er("spotify_oauth"),fa.current="link",await nr.initLoginWithOAuth("spotify")},linkInstagram:async()=>{ja("instagram"),er("instagram_oauth"),fa.current="link",await nr.initLoginWithOAuth("instagram")},linkTiktok:async()=>{ja("tiktok"),er("tiktok_oauth"),fa.current="link",await nr.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{ja("linkedin"),er("linkedin_oauth"),fa.current="link",await nr.initLoginWithOAuth("linkedin")},linkApple:async()=>{ja("apple"),er("apple_oauth"),fa.current="link",await nr.initLoginWithOAuth("apple")},linkPasskey:async()=>{ja("passkey"),er("passkey"),await nr.initLinkWithPasskey(),_a(mt.LINK_PASSKEY_SCREEN)},linkTelegram:async e=>{if(ja("telegram"),er("telegram"),fa.current="link",ga.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new E;v.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=A(e.launchParams.initDataRaw),ta({telegramAuthModalData:{seamlessAuth:!0}}),Ta(mt.TELEGRAM_AUTH_SCREEN)}else Tt(wa,"linkAccount","onError",Se.INVALID_DATA,{linkMethod:"telegram"});else await nr.initLoginWithTelegram();_a(mt.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{ja("farcaster"),er("farcaster"),await nr.initLoginWithFarcaster(),fa.current="link",ga.current="farcaster",_a(mt.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(ja("email"),!ae?.email)throw new Ue("User does not have an email linked to their account.");fa.current="update",ga.current="email",_a(mt.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(ja("sms"),!ae?.phone)throw new Ue("User does not have a phone number linked to their account.");fa.current="update",ga.current="sms",_a(mt.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!j){let e=await new Promise((e=>{ra((t=>e.bind(t)))}));if(ra(null),e)return void console.warn(t)}!ae||ae.isGuest?(fa.current="login",ta({login:e}),Ta(mt.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{j||(await new Promise((e=>{ra((()=>e))})),ra(null)),K?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(fa.current="login",Ta(mt.CONNECT_OR_CREATE))},logout:async()=>{if(fa.current=null,ga.current=null,ae&&v.clearProviderAcccessTokens(ae),Rt(null),await v.logout(),ae&&$t)try{await $t.clearMfa({userId:ae.id})}catch(e){}ne(null),z(!1),Tt(wa,"logout","onSuccess"),x(!1),J.del(H),J.del(G(Xt.id))},getAccessToken:()=>v.getCustomerAccessToken(),unlinkWallet:async e=>{let t;return ne(t=e.startsWith("0x")?await v.unlinkEthereumWallet(e):await v.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await v.unlinkEmail(e);return ne(t),t},unlinkPhone:async e=>{let t=await v.unlinkPhone(e);return ne(t),t},unlinkGoogle:async e=>{let t=await v.unlinkOAuth("google",e);return ne(t),t},unlinkTwitter:async e=>{let t=await v.unlinkOAuth("twitter",e);return ne(t),t},unlinkDiscord:async e=>{let t=await v.unlinkOAuth("discord",e);return ne(t),t},unlinkGithub:async e=>{let t=await v.unlinkOAuth("github",e);return ne(t),t},unlinkSpotify:async e=>{let t=await v.unlinkOAuth("spotify",e);return ne(t),t},unlinkInstagram:async e=>{let t=await v.unlinkOAuth("instagram",e);return ne(t),t},unlinkTiktok:async e=>{let t=await v.unlinkOAuth("tiktok",e);return ne(t),t},unlinkLinkedIn:async e=>{let t=await v.unlinkOAuth("linkedin",e);return ne(t),t},unlinkApple:async e=>{let t=await v.unlinkOAuth("apple",e);return ne(t),t},unlinkFarcaster:async e=>{let t=await v.unlinkFarcaster(e);return ne(t),t},unlinkTelegram:async e=>{let t=await v.unlinkTelegram(e);return ne(t),t},unlinkPasskey:async e=>{let t=await Ba();if(!t)throw Error("Must have valid access token to enroll in MFA");if(!$t)throw Error("Wallet proxy not initialized.");let a=Xt.passkeys.shouldUnenrollMfaOnUnlink;await $t.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:a});let r=await v.getAuthenticatedUser();return ne(r),r},unlinkCrossAppAccount:async({subject:e})=>{let t=ae?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Ue("Invalid subject");v.storeProviderAccessToken(t.id,null);let a=await v.unlinkOAuth(`privy:${t.id}`,e);return ne(a),a},createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let t=await nr.refreshSessionAndUser();if(!t)throw Tt(wa,"createWallet","onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return za(t,15e3,e)},setWalletRecovery:async e=>tr({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>tr({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(a,r)=>{let{requesterAppId:n}=t?.uiOptions||{},i=e.message;if(!K||!ae)return Tt(wa,"signMessage","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let o=t?.address??U(ae)?.address;if(!o)throw new Ue("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=P(ae,o);if(!s||!l)return Tt(wa,"signMessage","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));if("string"!=typeof i||i.length<1)return Tt(wa,"signMessage","onError",Se.INVALID_MESSAGE),void r(Error("Message must be a non-empty string"));Zt(!0);let c=async()=>{if(!K)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Ba();if(!$t||!e||!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:n}});let{entropyId:t,entropyIdVerifier:a}=C(l),{response:r}=await $t.rpc({accessToken:e,entropyId:t,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:n,request:{method:"personal_sign",params:[i,s.address]}}),o=r.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:n}}),o};if(Aa({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await c();Tt(wa,"signMessage","onSuccess",{signature:e}),a({signature:e})}catch(e){Tt(wa,"signMessage","onError",Se.UNABLE_TO_SIGN),r(e??new we("Unable to sign message"))}else{let e={method:"personal_sign",data:i,confirmAndSign:c,onSuccess:e=>{Tt(wa,"signMessage","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{Tt(wa,"signMessage","onError",Se.UNABLE_TO_SIGN),r(e)},uiOptions:t?.uiOptions||{}},{entropyId:n,entropyIdVerifier:o}=C(l);ta({signMessage:e,connectWallet:{entropyId:n,entropyIdVerifier:o,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{Tt(wa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t)=>new Promise((async(a,r)=>{let{requesterAppId:n}=t?.uiOptions||{};if(!K||!ae)return Tt(wa,"signTypedData","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let i=t?.address??U(ae)?.address;if(!i)throw new Ue("User must have an embedded wallet to sign a message.");let{signingWallet:o,rootWallet:s}=P(ae,i);if(!s||!o)return Tt(wa,"signTypedData","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));Zt(!0);let l=ee(e),c=async()=>{if(!K)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Ba();if(!$t||!e||!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:o.address,requesterAppId:n}});let{entropyId:t,entropyIdVerifier:a}=C(s),{response:r}=await $t.rpc({accessToken:e,entropyId:t,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:o.walletIndex??0,requesterAppId:n,request:{method:"eth_signTypedData_v4",params:[o.address,l]}}),i=r.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:o.address,requesterAppId:n}}),i};if(Aa({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await c();Tt(wa,"signTypedData","onSuccess",{signature:e}),a({signature:e})}catch(e){Tt(wa,"signTypedData","onError",Se.UNABLE_TO_SIGN),r(e??new we("Unable to sign message"))}else{let e={method:"eth_signTypedData_v4",data:l,confirmAndSign:c,onSuccess:e=>{Tt(wa,"signTypedData","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{Tt(wa,"signTypedData","onError",Se.UNABLE_TO_SIGN),r(e)},uiOptions:t?.uiOptions||{}},{entropyId:n,entropyIdVerifier:i}=C(s);ta({signMessage:e,connectWallet:{entropyId:n,entropyIdVerifier:i,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{Tt(wa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t)=>await Xa({transaction:e,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await Xa({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!K||!ae)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let r=e?.address??U(ae)?.address;if(!r)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=P(ae,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));Zt(!0);let{entropyId:o,entropyIdVerifier:s}=C(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:mt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0};ta(ea),await Ba()&&$t?$t?(ta({keyExport:{appId:T.appId,appClientId:T.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a},connectWallet:l}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:Ja,async init(e){switch(e){case"sms":return void await v.initMfaSmsVerification();case"passkey":return await v.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Ue("Invalid MFA code");ha.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{pa.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Ue("Invalid authenticator response");let a=await import("@simplewebauthn/browser"),r=dt(await a.startAuthentication(t));ha.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{pa.current={resolve:e,reject:t}}));break;default:throw ha.current?.reject(new Ue("Unsupported MFA method")),new Ue(`Unsupported MFA method: ${e}`)}},cancel(){ha.current?.reject(new Ue("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Ba();if(!t||!$t)throw Error("Must have valid access token to enroll in MFA");await $t.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,a)=>{if(!e)return nr.closePrivyModal(),void t();Xt.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),ta({mfaEnrollmentFlow:{mfaMethods:Xt.mfa.methods,shouldUnlinkOnUnenrollMfa:Xt.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:a}}),_a(mt.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Ba();if(!e||!$t)throw Error("Must have valid access token to enroll in MFA");let t=await $t.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Ba();if(!t||!$t)throw Error("Must have valid access token to enroll in MFA");await $t.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),ne(await v.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Ba();if(!t||!$t)throw Error("Must have valid access token to enroll in MFA");await $t.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),ne(await v.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let a=await Ba();if(!a||!$t)throw Error("Must have valid access token to enroll in MFA");await $t.submitEnrollMfa({method:"passkey",accessToken:a,credentialIds:e,removeForLogin:t.removeForLogin}),ne(await v.getAuthenticatedUser())},async unenroll(e,t={}){let a=await Ba();if(!a||!$t)throw Error("Must have valid access token to remove MFA");"passkey"===e?await $t.submitEnrollMfa({method:"passkey",accessToken:a,credentialIds:[],removeForLogin:t.removeForLogin}):await $t.unenrollMfa({method:e,accessToken:a}),ne(await v.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Ba(),t=ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!$t||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let a=await $t.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===a.status&&ne(await v.getAuthenticatedUser()||ae||null),ta({farcasterSigner:a}),_a(mt.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Ba(),a=ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!$t||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!ae.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=ae.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Ba(),a=ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!$t||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!ae.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),n=await $t.signFarcasterMessage({address:a.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(ae.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(ae&&!ae.isGuest)throw Error("User cannot already be authenticated to create a guest account");return ae?.isGuest?ae:nr.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t,chainId:a}){let r=ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ge({user:ae,client:v,address:t,requesterAppId:Xt.id,request:{method:r?"privy_signSmartWalletMessage":"personal_sign",params:[e,t],chainId:a},reconnect:ar})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:a}){let r=ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),n=ee(e);return Ge({user:ae,client:v,address:t,requesterAppId:Xt.id,request:{method:r?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,n],chainId:a},reconnect:ar})},sendTransactionWithCrossAppWallet(e,{address:t}){let a=ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ge({user:ae,client:v,address:t,requesterAppId:Xt.id,request:{method:a?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:ar})},isModalOpen:F,mfaMethods:Xt.mfa.methods};Ra=rr.signMessage,Da=rr.signTypedData,Ma=async(e,t)=>await Xa({transaction:e,...t,signOnly:!1}),Pa=async(e,t)=>({signature:(await Xa({transaction:e,...t,signOnly:!0})).hash});let nr={setAuthenticated:z,setUser:ne,isNewUserThisSession:Oe,pendingTransaction:null,walletConnectionStatus:Mt,connectors:v.connectors?.walletConnectors??[],solanaWallets:de,rpcConfig:Xt.rpcConfig,chains:Xt.chains,appId:T.appId,showFiatPrices:"native-token"!==Xt.embeddedWallets.priceDisplay.primary,clientAnalyticsId:v.clientAnalyticsId,customAuthStatus:da,hideWalletUIs:Ea,emailOtpState:jt,setEmailOtpState:Bt,smsOtpState:Vt,setSmsOtpState:Ht,oAuthState:Gt,setOAuthState:qt,siweState:Kt,setSiweState:zt,isHeadlessOAuthLoading:Dt,nativeTokenSymbolForChainId:e=>Xt.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if($t)return $t;let t=new Promise((e=>{ia((()=>t=>e(t)))})),a=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,a]);return ia(null),r},getAuthFlow:()=>v.authFlow,getAuthMeta:()=>v.authFlow?.meta,client:v,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=j&&K&&ae;a&&ga.current&&(t=Za(ae)),"login"===fa.current?e.shouldCallAuthOnSuccess&&a&&ga.current?Tt(wa,"login","onComplete",{user:ae,isNewUser:Oe,wasAlreadyAuthenticated:!1,loginMethod:ga.current,loginAccount:t??null}):Tt(wa,"login","onError",Se.USER_EXITED_AUTH_FLOW):"link"===fa.current&&t?e.isSuccess&&a&&ga.current?Tt(wa,"linkAccount","onSuccess",{user:ae,linkMethod:ga.current,linkedAccount:t}):ga.current&&Tt(wa,"linkAccount","onError",Se.USER_EXITED_LINK_FLOW,{linkMethod:ga.current}):"update"===fa.current&&t&&(e.isSuccess&&a&&ga.current?Tt(wa,"update","onSuccess",{user:ae,updateMethod:ga.current,updatedAccount:t}):ga.current&&Tt(wa,"update","onError",Se.USER_EXITED_UPDATE_FLOW,{linkMethod:ga.current}));let r=St&&Qe.includes(St),n=St===mt.ERROR_SCREEN&&ea.errorModalData&&Qe.includes(ea.errorModalData.previousScreen);if((r||n)&&ea.funding){let e,t=Je[St]??null;if("solana"===ea.funding.chainType){let a=I(pt);if(!a)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await a.getBalance({address:ea.funding.address,cluster:ea.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}Tt(wa,"fundSolanaWallet","onUserExited",{address:ea.funding.address,cluster:ea.funding.cluster,fundingMethod:t,balance:e})}else{let a=ft(ea.funding.chain.id,Xt.chains,Xt.rpcConfig,{appId:T.appId});try{e=await a.getBalance({address:ea.funding.address})}catch{console.error("Unable to pull wallet balance")}Tt(wa,"fundWallet","onUserExited",{address:ea.funding.address,chain:ea.funding.chain,fundingMethod:t,balance:e})}}ta({...ea,externalConnectWallet:{suggestedAddress:void 0}}),fa.current=null,ga.current=null,ut(!1),x(!1),setTimeout((()=>{v.authFlow=void 0}),200),v.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(a,r)=>{if(!K||!ae)return Tt(wa,"signMessage","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let n=t??S(ae)?.address;if(!n)throw new Ue("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=D(ae,n);if(!i||!o)return Tt(wa,"signMessage","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return Tt(wa,"signMessage","onError",Se.INVALID_MESSAGE),void r(Error("Message must be a non-empty string"));Zt(!0);let s=async()=>{if(!K)throw Error("User must be authenticated before signing with a Privy wallet");let t=await v.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let a=nr.walletProxy??await nr.initializeWalletProxy(15e3);if(!a)throw Error("Failed to initialize embedded wallet proxy.");if(!await nr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:r,entropyIdVerifier:n}=C(o),{response:s}=await a.rpc({accessToken:t,entropyId:r,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(Aa({showWalletUIs:void 0}))try{let e=await s();a({signature:e})}catch(e){r(e)}else{let{entropyId:t,entropyIdVerifier:n}=C(o);ta({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{a({signature:e})},onFailure:e=>{r(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{Tt(wa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),Ta(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendSolanaTransaction:async({transaction:e,connection:t,uiOptions:a,transactionOptions:r,fundWalletConfig:n,address:i})=>{let o=i?fe.find((e=>e.address===i)):fe.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw Tt(wa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),new Ue("Embedded wallet not found",Se.EMBEDDED_WALLET_NOT_FOUND);return await Qa({transaction:e,connection:t,transactionOptions:r,uiOptions:a,fundWalletConfig:n,wallet:o})},openPrivyModal:_a,connectWallet:Wa,initLoginWithWallet:async(e,t,a)=>{me(e)?(ga.current="siwe",Na(e,t,a)):(ga.current="siws",Ua(e,t,a))},loginWithWallet:async()=>{let e,t,a;if(!j)throw new Re;if(v.authFlow instanceof m?e="siwe":v.authFlow instanceof y&&(e="siws"),!e)throw new Ue("Must initialize SIWE/SIWS flow first.");if(null!==await v.getAccessToken())try{({user:t}=await v.link()),ga.current=e}catch(t){throw Tt(wa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:a}=await v.authenticate()),ga.current=e}catch(e){throw Tt(wa,"login","onError",e.privyErrorCode||Se.GENERIC_CONNECT_WALLET_ERROR),e}ne(t||ae||null),ut(a||!1),z(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:a})=>new Promise((async(r,n)=>{let i=await Ba();if(!K||!ae||!i)throw new Ue("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Ue("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let o=nr.walletProxy??await nr.initializeWalletProxy(15e3);if(!o)throw new Ue("Wallet proxy not initialized.");if(Te({address:e,chainType:t,user:ae}))return r();let s=ve({address:e,user:ae}),l=Ce({address:e,user:ae}),c=async()=>{await o.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[s]}),await nr.refreshSessionAndUser()};if(!a){try{await c(),r()}catch(e){n(e)}return}await nr.recoverPrimaryWallet(),ta({delegatedActions:{consent:{address:e,onDelegate:c,onSuccess:async()=>{r()},onError:async e=>{n(e)}}}}),_a(mt.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,a)=>{if(!K||!ae)throw new Ue("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===Ie(ae).length)throw new Ue("User has no delegated wallets to revoke.");let r=async()=>{await v.revokeDelegatedWallet(),await nr.refreshSessionAndUser()};if(e)ta({delegatedActions:{revoke:{onRevoke:r,onSuccess:async()=>{t()},onError:async e=>{a(e)}}}}),_a(mt.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN);else try{await r(),t()}catch(e){a(e)}})),initLoginWithFarcaster:async(e,t)=>{let a=new h(e,t);v.startAuthFlow(a);try{ga.current="farcaster",await a.initializeFarcasterConnect()}catch(e){throw"login"===fa.current?Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===fa.current&&Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!j)throw new Re;if(!(v.authFlow instanceof h))throw new Ue("Must initialize Farcaster flow first.");if(null!==await v.getAccessToken())try{({user:e}=await v.link()),ga.current="farcaster"}catch(e){throw Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await v.authenticate()),ga.current="farcaster"}catch(e){throw Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ne(e||null),ut(t||!1),z(!0)},async loginWithGuestAccountFlow(){let e=new p(this.appId);v.startAuthFlow(e);try{fa.current="login",ga.current="guest";let{user:e,isNewUser:t}=await v.authenticate();if(t=t||!1,!e)throw new Ue("Unable to authenticate guest account");let a=await Ba(),r=await nr.initializeWalletProxy(q);if(a&&r)try{let t=st(e,Xt.embeddedWallets.ethereum.createOnLogin),n=lt(e,Xt.embeddedWallets.solana.createOnLogin);if(t&&n){let t=await za(e,q);await r.createSolana({accessToken:a,ethereumAddress:t?.address}),e=await nr.refreshSessionAndUser()}else n?(await r.createSolana({accessToken:a,ethereumAddress:U(e)?.address}),e=await nr.refreshSessionAndUser()):t?(await za(e,q),e=await nr.refreshSessionAndUser()):ne(e)}catch(t){ne(e),console.warn("Unable to create embedded wallet for guest account")}return ut(t),z(!0),Tt(wa,"login","onComplete",{user:e,isNewUser:t,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),e}catch(e){throw Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:a}){let r=`privy:${e}`;ga.current=r;let{url:n,stateCode:i,codeVerifier:o}=await Ve({api:v.api,appId:e});if(!n)throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Ue("No authorization URL returned for cross-app auth.");try{let s=await ze({url:n,popup:t,provider:r}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:i??"",returnedStateCode:l??""}}),new Ue("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);let d=await He({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:a,client:v});d&&v.storeProviderAccessToken(e,d);let u=await nr.refreshSessionAndUser();if(!u)throw new Ue("Unable to update user");return v.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:r}}),e}},async initLoginWithOAuth(e,t,a){if(ga.current=e,!Z())return void Ta(mt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&et(window.navigator.userAgent))return void Ta(mt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:xe},"*"),J.del($),J.del(Y);let r=new Ot({provider:e,disableSignup:!!a,withPrivyUi:!0});t&&r.addCaptchaToken(t),v.startAuthFlow(r);let n=await v.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&s&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!j)throw new Re;ga.current="telegram";let a=new E(e,t);v.startAuthFlow(a),a.meta.telegramWebAppData=void 0,a.meta.telegramAuthResult=await new Promise(((e,t)=>Xt.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:Xt.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(a=>a?e(a):t(new Ue("Telegram auth failed or was canceled by the client")))):t(new Ue("Telegram was not initialized")):t(new Ue("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,a;if(!(v.authFlow instanceof E))throw new Ue("Must initialize Telegram flow before calling loginWithTelegram");if(v.authFlow.meta.captchaToken||=e,"login"===fa.current)try{let e=await v.authenticate();t=e.user,a=e.isNewUser,ga.current="telegram"}catch(e){throw Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}else{if("link"!==fa.current)throw new Ue("Unknown auth intent");try{t=(await v.link()).user,ga.current="telegram"}catch(e){throw Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}ne(t),ut(a||!1),z(!0)},async recoveryOAuthFlow(e,t,a){let r,n;function i(t){if(!t)throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new Ue("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await qe({api:Sa.api,provider:e});i(s);try{let r=await at({url:s,popup:a,provider:e});if(t=r.stateCode,o=r.authorizationCode,t!==c)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new Ue("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED)}catch(t){throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new Ue("Recovery OAuth failed")}[r,n]=await Promise.all([Ba(),$e({api:Sa.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await qe({api:Sa.api,provider:e});i(t);let{ckWebAuthToken:o}=await at({url:t,popup:a,provider:e});n=o,r=await Ba()}}if(!$t)throw new Ue("Cannot connect to wallet proxy");if(!r)throw new Ue("Unable to authorize user");switch(t){case"recover":{let t=ea.recoverWallet?.entropyId,a=ea.recoverWallet?.entropyIdVerifier;if(!t||!a)throw new Ue("Recovery OAuth failed");v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await $t.recover({accessToken:r,entropyId:t,entropyIdVerifier:a,recoveryAccessToken:n}),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{v.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await $t.create({accessToken:r,recoveryAccessToken:n,recoveryMethod:e});let t=U(await nr.refreshSessionAndUser());if(!t)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),Tt(wa,"createWallet","onSuccess",{wallet:t});break}case"set-recovery":{let t=N(ae);if(!t)throw Tt(wa,"setWalletRecovery","onError",Se.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:a,entropyIdVerifier:i}=C(t);await $t.setRecovery({accessToken:r,entropyId:a,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=N(await nr.refreshSessionAndUser());if(!o)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),Tt(wa,"setWalletRecovery","onSuccess",{method:e,wallet:o});break}default:throw new Ue("Unsupported recovery action")}},async loginWithOAuth(e){let t,a,r;if(!(v.authFlow instanceof Ot))throw new Ue("Must initialize OAuth flow before calling loginWithOAuth");let n=J.get(X),i=v.authFlow.meta.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new Ue("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{let a=await v.link();t=a.user,r=a.oAuthTokens,ga.current=e}catch(t){throw Tt(wa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await v.authenticate();t=n.user,a=n.isNewUser,r=n.oAuthTokens,ga.current=e}catch(t){throw"login"===fa.current?Tt(wa,"login","onError",t.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===fa.current&&Tt(wa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return ne(t),ut(a||!1),z(!0),r&&t&&Tt(wa,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:r,user:t}),r},passkeyAuthState:Ft,setPasskeyAuthState:xt,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let a=new w({captchaToken:e,setPasskeyAuthState:xt});v.startAuthFlow(a),fa.current="login";try{ga.current="passkey",xt({status:"generating-challenge"}),await a.initRegisterFlow(t),xt({status:"awaiting-passkey"})}catch(e){throw xt({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!j)throw new Re;if(!(v.authFlow instanceof w))throw new Ue("Must initialize Passkey flow first.");if("passkey"!==ga.current){let e=new Ue("Must init login with Passkey flow first.");throw xt({status:"error",error:e}),e}let a=await Ba();try{ga.current="passkey",xt({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await v.authenticate())}catch(e){throw xt({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ne(e),ut(t||!1),z(!0),xt({status:"done"});let r=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!a,loginAccount:r}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let a=new w({captchaToken:e,setPasskeyAuthState:xt});v.startAuthFlow(a),fa.current="login";try{ga.current="passkey",xt({status:"generating-challenge"}),await a.initAuthenticationFlow(t),xt({status:"awaiting-passkey"})}catch(e){throw xt({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!j)throw new Re;if(!(v.authFlow instanceof w))throw new Ue("Must initialize Passkey flow first.");if("passkey"!==ga.current){let e=new Ue("Must init login with Passkey flow first.");throw xt({status:"error",error:e}),e}let a=await Ba();try{ga.current="passkey",xt({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await v.authenticate())}catch(e){throw xt({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ne(e),ut(t||!1),z(!0),xt({status:"done"});let r=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!a,loginAccount:r}},async initLinkWithPasskey(e){let t=new w({captchaToken:e});v.startAuthFlow(t),fa.current="link",ga.current="passkey",xt({status:"generating-challenge"});try{await t.initLinkFlow(),xt({status:"awaiting-passkey"})}catch(e){throw Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),xt({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!j)throw new Re;if(!(v.authFlow instanceof w))throw new Ue("Must initialize Passkey flow first.");if("passkey"!==ga.current)throw new Ue("Must init login with Passkey flow first.");try{ga.current="passkey",({user:e}=await v.link())}catch(e){throw Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return ne(e||ae||null),xt({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,a){if(!Z())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&et(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let r=new Ot({provider:e,withPrivyUi:!1,disableSignup:a??!1});t&&r.addCaptchaToken(t),qt({status:"loading"});let n=await v.startAuthFlow(r).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,a,r;Pt(!0),qt({status:"loading"}),v.startAuthFlow(new Ot(e));let n=J.get(X),i=e.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Pt(!1),new Ue("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{({user:t,oAuthTokens:r}=await v.link()),ga.current=e.provider;let a=Za(t);t&&a&&Tt(wa,"linkAccount","onSuccess",{user:t,linkMethod:ga.current,linkedAccount:a})}catch(t){throw Pt(!1),Tt(wa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:a,oAuthTokens:r}=await v.authenticate()),ga.current=e.provider;let n=Za(t);t&&n&&void 0!==a&&Tt(wa,"login","onComplete",{user:t,isNewUser:a,wasAlreadyAuthenticated:!1,loginMethod:ga.current,loginAccount:n})}catch(e){throw Pt(!1),qt({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}return ne(t),ut(a||!1),z(!0),Pt(!1),qt({status:"done"}),r&&t&&Tt(wa,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:r,user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{let n=new u({email:e,captchaToken:t,disableSignup:a});v.startAuthFlow(n);try{ga.current="email",Bt({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:r}),Bt({status:"awaiting-code-input"})}catch(e){throw Bt({status:"error",error:e}),"login"===fa.current?Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===fa.current&&Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,a)=>{let r=new d(e,t,a);v.startAuthFlow(r);try{await r.sendCodeEmail({withPrivyUi:!0})}catch(e){Tt(wa,"update","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:ga.current})}},initUpdatePhone:async(e,t,a)=>{let r=new g(e,t,a);v.startAuthFlow(r);try{await r.sendSmsCode({withPrivyUi:!0})}catch(e){Tt(wa,"update","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:ga.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{Ht({status:"sending-code"});let n=new f({phoneNumber:e,captchaToken:t,disableSignup:a});v.startAuthFlow(n);try{ga.current="sms",await n.sendSmsCode({withPrivyUi:r}),Ht({status:"awaiting-code-input"})}catch(e){throw Ht({status:"error",error:e}),"login"===fa.current?Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===fa.current&&Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(v.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(v.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,a;function r(e){v.authFlow instanceof u?Bt(e):v.authFlow instanceof f&&Ht(e)}if(r({status:"submitting-code"}),!j){let e=new Re;throw r({status:"error",error:e}),e}if(v.authFlow instanceof u)v.authFlow.meta.emailCode=e.trim();else{if(!(v.authFlow instanceof f)){let e=new Ue("Must initialize a passwordless code flow first");throw r({status:"error",error:e}),e}v.authFlow.meta.smsCode=e.trim()}let n=await Ba();if("link"===fa.current)try{({user:t}=await v.link())}catch(e){throw r({status:"error",error:e}),Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:ga.current}),e}else if("update"===fa.current)try{({user:t}=await v.link())}catch(e){throw r({status:"error",error:e}),Tt(wa,"update","onError",e.privyErrorCode||Se.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:ga.current}),e}else try{({user:t,isNewUser:a}=await v.authenticate())}catch(e){throw r({status:"error",error:e}),Tt(wa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}let i=t||ae;ne(i||null),ut(a||!1),z(!0),r({status:"done"});let o=null;return v.authFlow instanceof u?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:v.authFlow instanceof f&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:a||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:a})=>{fa.current="link",ga.current="siwe",zt({status:"generating-message"});let r=await v.generateSiweNonce({address:e,captchaToken:a});return zt({status:"awaiting-signature"}),rt({address:e,chainId:t.replace("eip155:",""),nonce:r})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let a=await v.generateSiweNonce({address:e});return rt({address:e,chainId:t.replace("eip155:",""),nonce:a})},linkSmartWallet:async({message:e,signature:t,smartWalletType:a})=>{let r;r=await v.linkSmartWallet({message:e,signature:t,smartWalletType:a}),ne((r=await nr.refreshSessionAndUser()??r)||ae||null)},linkWithSiwe:async({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})=>{let i;ja("siwe");let o=null;try{zt({status:"submitting-signature"}),i=await v.linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}),i=await nr.refreshSessionAndUser()??i,zt({status:"done"}),(o=Za(i)||null)&&Tt(wa,"linkAccount","onSuccess",{user:i,linkMethod:"siwe",linkedAccount:o})}catch(e){throw Tt(wa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),fa.current=null,ga.current=null,zt({status:"error",error:e}),e}let s=i||ae;return ne(s||null),fa.current=null,ga.current=null,{user:s,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await v.getAuthenticatedUser();return z(!!e),ne(e),e},walletProxy:$t,createAnalyticsEvent:({eventName:e,payload:t,timestamp:a})=>v.createAnalyticsEvent({eventName:e,payload:t,timestamp:a}),acceptTerms:async()=>{let e=await v.acceptTerms();return ne(e),e},getUsdTokenPrice:e=>v.getUsdTokenPrice(e),getUsdPriceForSol:()=>v.getUsdPriceForSol(),getSplTokenMetadata:e=>v.getSplTokenMetadata(e),recoverPrimaryWallet:async e=>new Promise((async(t,a)=>{let r=N(e?.user??ae)||O(e?.user??ae)||W(e?.user??ae);r||t(!0);let n=await Ba();if(!n||!$t||!r)return void a(Error("Must have valid access token and Privy wallet to recover wallet"));Zt(!0);let{entropyId:i,entropyIdVerifier:o}=C(r);try{await $t.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){ke(e)&&"privy"===r.recoveryMethod?(v.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:r.address}}),(await $t.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||a(Error("Unable to recover wallet")),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:r.address}}),t(!0)):ke(e)&&"privy"!==r.recoveryMethod?(ta({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:a,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:r.recoveryMethod,action:"recover"}}),_a(Ye(r.recoveryMethod))):a(e)}})),embeddedSolanaWallets:fe,createEmbeddedSolanaWallet:async e=>{e&&"target"in e&&(e=void 0);let t=await nr.refreshSessionAndUser();if(!t)throw Tt(wa,"createWallet","onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,a)=>{let r=U(e),n=S(e),i=a&&"createAdditional"in a&&a.createAdditional,o=a&&"walletIndex"in a?a.walletIndex:void 0,s=(M(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw Tt(wa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([nr.initializeWalletProxy(t),Ba()]);if(!l||!c)throw Tt(wa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await $a({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:r})})(t,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,a)=>{if(!K||!ae)return void a(Error("User must be authenticated before exporting their Privy wallet"));let r=e?.address??S(ae)?.address;if(!r)return void a(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=D(ae,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));if(Zt(!0),!await Ba()||!$t)return void a(Error("Must have valid access token to enroll in MFA"));if(!$t)return void a(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=C(i);ta({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:mt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0},keyExport:{appId:T.appId,appClientId:T.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a}}),_a(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{V(!0),aa?.(e)},updateWallets:()=>Ka(),fundWallet:async(e,t)=>{let a=mt.FUNDING_METHOD_SELECTION_SCREEN;ta({funding:Ut({address:e,appConfig:Xt,fundWalletConfig:t,methodScreen:a})}),_a(a)},openModal:_a,requestFarcasterSignerStatus:async e=>{let t=await Ba(),a=ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!$t||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let r=await v.requestFarcasterSignerStatus(e);return"approved"===r.status&&ne(await v.getAuthenticatedUser()||ae||null),r},connectCoinbaseSmartWallet:async()=>{Xt.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=v.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||v.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),Wa(e);await ka("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s})=>{let l=await v.sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s});return ne(l),l}};La=nr.recoverPrimaryWallet,Fa=nr.recoverPrimaryWallet,xa=nr.solanaSignMessage;let ir=o((()=>({wallets:ie,ready:oa&&ma})),[ie,oa,ma]),or=v.authFlow instanceof E,sr=!Xt.headless&&Xt.captchaEnabled&&!K&&(j||or);/*#__PURE__*/return e(kt.Provider,{value:rr,children:/*#__PURE__*/e(vt.Provider,{value:wa,children:/*#__PURE__*/e(Wt.Provider,{value:ir,children:/*#__PURE__*/e(At,{...Xt,children:/*#__PURE__*/t(Ct.Provider,{value:nr,children:[/*#__PURE__*/e(wt,{children:/*#__PURE__*/t(It,{data:ea,setModalData:ta,setInitialScreen:Rt,initialScreen:St,authenticated:K,open:F,children:[T.children,sr&&/*#__PURE__*/e(se,{delayedExecution:!1}),/*#__PURE__*/e(gt,{theme:{...Xt.appearance.palette||{}}}),!Xt.render.standalone&&/*#__PURE__*/e(le,{open:F})]})}),Jt&&Qt?/*#__PURE__*/e(_e,{appId:T.appId,appClientId:T.clientId,clientAnalyticsId:v.clientAnalyticsId,origin:v.apiUrl,mfaMethods:ae?.mfaMethods,mfaPromise:ha,mfaSubmitPromise:pa,onLoad:Yt,onLoadFailed:()=>null}):null,Xt.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/e(yt,{$if:!0,children:/*#__PURE__*/e(ce,{scriptHost:T.apiUrl||B,botUsername:Xt.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};export{Ia as C,Ca as E,Ya as P,Ua as a,Oa as b,Ba as c,Va as d,Ha as e,Ka as f,ja as g,za as h,Ga as i,qa as j,$a as k};

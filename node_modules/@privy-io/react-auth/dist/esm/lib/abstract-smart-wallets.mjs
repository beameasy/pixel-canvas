import{createAbstractClient as n}from"@abstract-foundation/agw-client";import{hexToNumber as o,createWalletClient as e,custom as r,http as t}from"viem";import{toAccount as s}from"viem/accounts";import{abstractTestnet as i}from"viem/chains";import{getEntropyDetailsFromUser as a}from"../client/user.mjs";import{usePrivyInternal as c}from"../hooks/internal-context.mjs";import{usePrivyModal as m}from"../hooks/modal-context.mjs";import{usePrivyContext as l}from"../hooks/privy-context.mjs";import{useWallets as p}from"../hooks/useWallets.mjs";import{ModalScreen as d}from"../screens/index.mjs";import{getJsonRpcEndpointFromChain as h}from"../utils/eth/getPublicClient.mjs";import{getEmbeddedConnectedWallet as u}from"./getEmbeddedConnectedWallet.mjs";import{callsToTransactionRequests as E}from"./smart-wallets.mjs";import"viem/utils";import"react";import"../hooks/index.mjs";import"react/jsx-runtime";import"../components/PrefetchedImage.mjs";import"../configuration/context.mjs";import"../config.mjs";import"../configuration/defaultClientConfig.mjs";import"../constants.mjs";import"../configuration/login-methods.mjs";import"../configuration/wallets.mjs";import"../connectors/chains/index.mjs";import"../connectors/chains/arbitrum.mjs";import"../connectors/chains/arbitrumSepolia.mjs";import"../connectors/chains/avalanche.mjs";import"../connectors/chains/avalancheFuji.mjs";import"../connectors/chains/base.mjs";import"../connectors/chains/baseSepolia.mjs";import"../connectors/chains/berachainArtio.mjs";import"../connectors/chains/celo.mjs";import"../connectors/chains/celoAlfajores.mjs";import"../connectors/chains/filecoin.mjs";import"../connectors/chains/filecoinCalibration.mjs";import"../connectors/chains/garnetHolesky.mjs";import"../connectors/chains/holesky.mjs";import"../connectors/chains/linea.mjs";import"../connectors/chains/lineaTestnet.mjs";import"../connectors/chains/lukso.mjs";import"../connectors/chains/mainnet.mjs";import"../connectors/chains/optimism.mjs";import"../connectors/chains/optimismSepolia.mjs";import"../connectors/chains/polygon.mjs";import"../connectors/chains/polygonAmoy.mjs";import"../connectors/chains/redstone.mjs";import"../connectors/chains/sepolia.mjs";import"../connectors/chains/zora.mjs";import"../connectors/chains/zoraSepolia.mjs";import"../connectors/chains/zoraTestnet.mjs";import"../connectors/chains/utils.mjs";import"./solana/index.mjs";import"../theme.mjs";import"tinycolor2";import"./cybr53.mjs";import"../errors.mjs";import"ofetch";import"../hooks/useSmartWalletChain.mjs";import"./smart-wallets-shared.mjs";import"permissionless";import"permissionless/accounts";import"permissionless/clients/pimlico";import"viem/account-abstraction";import"@privy-io/js-sdk-core";function y(){let{user:y}=l(),{hideWalletUIs:g,openPrivyModal:f,chains:j,appId:I,rpcConfig:T}=c(),{wallets:C}=p(),{setModalData:N}=m(),D=async(a=i.id)=>{let c=u(C);if(!c)throw Error("No connected wallet found");let m="string"==typeof a?o(a):a;if(![i.id,2741].includes(m))throw Error("Error, only Abstract chains are supported");let l=j.find((n=>n.id===m));if(!l)throw Error("Chain not configured");await c.switchChain(l.id);let p=await c.getEthereumProvider(),d=e({account:c.address,transport:r(p)}),E=s({address:c.address,signMessage:d.signMessage,signTransaction:d.signTransaction,signTypedData:d.signTypedData});return await n({chain:l,transport:t(h(l,T,I)),publicTransport:t(h(l,T,I)),signer:E})};return{signMessage:async({message:n},o)=>{let e=await D(o);return new Promise((async(o,r)=>{let{entropyId:t,entropyIdVerifier:s}=a(y);g.current=!0,N({connectWallet:{entropyId:t,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:n,confirmAndSign:()=>e.signMessage({message:n}),onSuccess:n=>o(n),onFailure:r,uiOptions:{isCancellable:!0}}}),f(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{g.current=!1}))},signTypedData:async(n,o)=>{let e=await D(o);return new Promise((async(o,r)=>{g.current=!0;let{entropyId:t,entropyIdVerifier:s}=a(y);N({connectWallet:{entropyId:t,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:n,confirmAndSign:()=>e.signTypedData(n),onSuccess:n=>o(n),onFailure:r,uiOptions:{isCancellable:!0}}}),f(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{g.current=!1}))},sendTransaction:async n=>{let o=await D(n.chainId),e=[],r="calls"in n&&void 0!==n.calls;return e=r?[...n.calls]:[n],new Promise((async(t,s)=>{g.current=!0;let{entropyId:i,entropyIdVerifier:c}=a(y);N({connectWallet:{entropyId:i,entropyIdVerifier:c,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:E({calls:e,chain:o.chain,maxPriorityFeePerGas:n.maxPriorityFeePerGas,maxFeePerGas:n.maxFeePerGas,nonce:n.nonce?BigInt(n.nonce):void 0}),entropyId:i,entropyIdVerifier:c,transactingWallet:{address:o.account.address,walletIndex:null},signOnly:!1,getIsSponsored:async()=>void 0!==n.paymaster&&void 0!==n.paymasterInput,onConfirm:()=>r?o.sendTransactionBatch(n):o.sendTransaction(n),onSuccess:n=>t(n.hash),onFailure:s,uiOptions:{isCancellable:!0}}}),f(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{g.current=!1}))},signTransaction:async n=>{let o=await D(n.chainId),e=[],r="calls"in n&&void 0!==n.calls;return e=r?[...n.calls]:[n],new Promise((async(t,s)=>{g.current=!0;let{entropyId:i,entropyIdVerifier:c}=a(y);N({connectWallet:{entropyId:i,entropyIdVerifier:c,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:E({calls:e,chain:o.chain,maxPriorityFeePerGas:n.maxPriorityFeePerGas,maxFeePerGas:n.maxFeePerGas,nonce:n.nonce?BigInt(n.nonce):void 0}),entropyId:i,entropyIdVerifier:c,transactingWallet:{address:o.account.address,walletIndex:null},signOnly:!0,getIsSponsored:async()=>void 0!==n.paymaster&&void 0!==n.paymasterInput,onConfirm:()=>{if(!r)return o.signTransaction(n);throw Error("Batch transactions not supported for signing")},onSuccess:n=>t(n.hash),onFailure:s,uiOptions:{isCancellable:!0}}}),f(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{g.current=!1}))}}}export{y as useAbstractSmartWallets};

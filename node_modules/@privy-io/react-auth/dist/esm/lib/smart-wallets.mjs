import{useCallback as e}from"react";import{createPublicClient as n,http as t}from"viem";import{getEntropyDetailsFromUser as r}from"../client/user.mjs";import{useAppConfig as a}from"../configuration/context.mjs";import{PrivyClientError as i}from"../errors.mjs";import{usePrivyInternal as o}from"../hooks/internal-context.mjs";import{usePrivyModal as s}from"../hooks/modal-context.mjs";import{usePrivyContext as c}from"../hooks/privy-context.mjs";import{useSmartWalletChains as l}from"../hooks/useSmartWalletChain.mjs";import{useWallets as m}from"../hooks/useWallets.mjs";import{ModalScreen as p}from"../screens/index.mjs";import{getJsonRpcEndpointFromChain as d}from"../utils/eth/getPublicClient.mjs";import{getEmbeddedConnectedWallet as u}from"./getEmbeddedConnectedWallet.mjs";import{signerToSmartAccountClient as y}from"./smart-wallets-shared.mjs";import"viem/utils";import"react/jsx-runtime";import"../config.mjs";import"../configuration/defaultClientConfig.mjs";import"../constants.mjs";import"../configuration/login-methods.mjs";import"../configuration/wallets.mjs";import"../connectors/chains/index.mjs";import"../connectors/chains/arbitrum.mjs";import"../connectors/chains/arbitrumSepolia.mjs";import"../connectors/chains/avalanche.mjs";import"../connectors/chains/avalancheFuji.mjs";import"../connectors/chains/base.mjs";import"../connectors/chains/baseSepolia.mjs";import"../connectors/chains/berachainArtio.mjs";import"../connectors/chains/celo.mjs";import"../connectors/chains/celoAlfajores.mjs";import"../connectors/chains/filecoin.mjs";import"../connectors/chains/filecoinCalibration.mjs";import"../connectors/chains/garnetHolesky.mjs";import"../connectors/chains/holesky.mjs";import"../connectors/chains/linea.mjs";import"../connectors/chains/lineaTestnet.mjs";import"../connectors/chains/lukso.mjs";import"../connectors/chains/mainnet.mjs";import"../connectors/chains/optimism.mjs";import"../connectors/chains/optimismSepolia.mjs";import"../connectors/chains/polygon.mjs";import"../connectors/chains/polygonAmoy.mjs";import"../connectors/chains/redstone.mjs";import"../connectors/chains/sepolia.mjs";import"../connectors/chains/zora.mjs";import"../connectors/chains/zoraSepolia.mjs";import"../connectors/chains/zoraTestnet.mjs";import"../connectors/chains/utils.mjs";import"./solana/index.mjs";import"../theme.mjs";import"tinycolor2";import"./cybr53.mjs";import"ofetch";import"../hooks/index.mjs";import"../components/PrefetchedImage.mjs";import"permissionless";import"permissionless/accounts";import"permissionless/clients/pimlico";import"viem/account-abstraction";import"@privy-io/js-sdk-core";const h=({calls:e,chain:n,maxPriorityFeePerGas:t,maxFeePerGas:r,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:n.id,nonce:a,maxFeePerGas:r,maxPriorityFeePerGas:t}))),f=async({chain:e,paymasterContext:r,embeddedWallet:a,user:o,smartWalletsConfig:s,rpcConfig:c,privyAppId:l})=>{if(!s?.enabled||!o||!a)return;let m=await a.getEthereumProvider(),p=s?.configuredNetworks.find((n=>n.chainId===`eip155:${e.id}`));if(!p)throw new i(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let u=o.smartWallet?.smartWalletType??s.smartWalletType,h=d(e,c,l),f=n({chain:e,transport:t(h)}),E=r??p.paymasterContext,g=await y({owner:m,smartWalletType:u,chain:e,publicClient:f,paymasterContext:E,...p});if(!g)throw new i(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return g},E=({clientConfig:n,smartWalletsConfig:t})=>{let{hideWalletUIs:d,openPrivyModal:y,appId:E}=o(),g=a(),{setModalData:I}=s(),{user:C}=c(),{chains:j}=a(),{chainId:T,clients:D,setChainId:w,chainIdState:N}=l(),S=j.find((e=>e.id===N)),{wallets:_}=m(),W=e((async()=>T.current),[T]),P=e((async({id:e})=>{if(!D.current[e]){let r=u(_),a=await f({chain:j.find((n=>n.id===e)),embeddedWallet:r,user:C,paymasterContext:n?.paymasterContext,smartWalletsConfig:t,rpcConfig:g.rpcConfig,privyAppId:E});a&&(D.current[e]=a)}w(e)}),[j,n,_,C,t]);return{wrapSmartAccountClient:e=>{D.current[e.chain.id]=e,N||w(e.chain.id);return{...e,sendTransaction:async(e,n)=>{let t=D.current[T.current];if(!t)throw new i(`Smart wallet client for chain (eip155:${T.current}) not found`);if(delete e.account,!g.embeddedWallets.showWalletUIs)return d.current=!0,await t.sendTransaction(e).finally((()=>d.current=!1));let a=[];"calls"in e&&void 0!==e.calls?a=[...e.calls]:"to"in e&&(a=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let o=async()=>{if(!t.paymaster)return!1;let{paymasterAndData:n,paymasterData:r}=await t.prepareUserOperation({calls:a,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return Number(n??r??0)>0};return new Promise((async(i,s)=>{d.current=!0;let{entropyId:c,entropyIdVerifier:l}=r(C);I({connectWallet:{entropyId:c,entropyIdVerifier:l,onCompleteNavigateTo:p.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:h({calls:a,chain:t.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:c,entropyIdVerifier:l,transactingWallet:{address:t.account.address,walletIndex:null},getIsSponsored:o,signOnly:!1,onConfirm:()=>t.sendTransaction(e),onSuccess:e=>i(e.hash),onFailure:s,uiOptions:n?.uiOptions??{}}}),y(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{d.current=!1}))},signMessage:async(e,n)=>{let t=D.current[T.current];if(!t)throw new i(`Smart wallet client for chain (eip155:${T.current}) not found`);return g.embeddedWallets.showWalletUIs?new Promise((async(a,i)=>{let{entropyId:o,entropyIdVerifier:s}=r(C);d.current=!0,I({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>t.signMessage(e),onSuccess:e=>a(e),onFailure:i,uiOptions:n?.uiOptions??{}}}),y(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{d.current=!1})):(d.current=!0,await t.signMessage(e).finally((()=>d.current=!1)))},signTypedData:async(e,n)=>{let t=D.current[T.current];if(!t)throw new i(`Smart wallet client for chain (eip155:${T.current}) not found`);return delete e.account,g.embeddedWallets.showWalletUIs?new Promise((async(a,i)=>{d.current=!0;let{entropyId:o,entropyIdVerifier:s}=r(C);I({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>t.signTypedData(e),onSuccess:e=>a(e),onFailure:i,uiOptions:n?.uiOptions??{}}}),y(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{d.current=!1})):(d.current=!0,await t.signTypedData(e).finally((()=>d.current=!1)))},getChainId:W,chain:S,switchChain:P}}}},g=()=>{let{hideWalletUIs:e,openPrivyModal:n}=o(),t=a(),{setModalData:i}=s(),{user:l}=c();return{wrapSmartAccountClientWithUIs:a=>({...a,sendTransaction:async(o,s)=>{if(!t.embeddedWallets.showWalletUIs)return e.current=!0,await a.sendTransaction(o).finally((()=>e.current=!1));let c=[];"calls"in o&&void 0!==o.calls?c=[...o.calls]:"to"in o&&(c=[{to:o.to,value:o.value||BigInt(0),data:o.data||"0x"}]);let m=async()=>{if(!a.paymaster)return!1;let{paymasterAndData:e,paymasterData:n}=await a.prepareUserOperation({calls:c,maxFeePerGas:o.maxFeePerGas,maxPriorityFeePerGas:o.maxPriorityFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0});return Number(e??n??0)>0};return new Promise((async(t,d)=>{e.current=!0;let{entropyId:u,entropyIdVerifier:y}=r(l);i({connectWallet:{entropyId:u,entropyIdVerifier:y,onCompleteNavigateTo:p.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:h({calls:c,chain:a.chain,maxPriorityFeePerGas:o.maxPriorityFeePerGas,maxFeePerGas:o.maxFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0}),entropyId:u,entropyIdVerifier:y,transactingWallet:{address:a.account.address,walletIndex:null},getIsSponsored:m,signOnly:!1,onConfirm:()=>a.sendTransaction(o),onSuccess:e=>t(e.hash),onFailure:d,uiOptions:s?.uiOptions??{}}}),n(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async(o,s)=>t.embeddedWallets.showWalletUIs?new Promise((async(t,c)=>{let{entropyId:m,entropyIdVerifier:d}=r(l);e.current=!0,i({connectWallet:{entropyId:m,entropyIdVerifier:d,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof o.message?o.message:o.message.raw.toString(),confirmAndSign:()=>a.signMessage(o),onSuccess:e=>t(e),onFailure:c,uiOptions:s?.uiOptions??{}}}),n(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})):(e.current=!0,await a.signMessage(o).finally((()=>e.current=!1))),signTypedData:async(o,s)=>t.embeddedWallets.showWalletUIs?new Promise((async(t,c)=>{e.current=!0;let{entropyId:m,entropyIdVerifier:d}=r(l);i({connectWallet:{entropyId:m,entropyIdVerifier:d,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:o,confirmAndSign:()=>a.signTypedData(o),onSuccess:e=>t(e),onFailure:c,uiOptions:s?.uiOptions??{}}}),n(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})):(e.current=!0,await a.signTypedData(o).finally((()=>e.current=!1)))})}};export{h as callsToTransactionRequests,f as getSmartWalletClient,g as useSmartWalletsUIWrapper,E as useSmartWalletsWrapper};
